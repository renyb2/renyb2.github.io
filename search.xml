<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dijkstra</title>
    <url>/2020/08/27/Dijkstra/</url>
    <content><![CDATA[<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="问题1：最短路径"><a href="#问题1：最短路径" class="headerlink" title="问题1：最短路径"></a>问题1：最短路径</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="/2020/08/27/Dijkstra/Dijkstra-%E9%97%AE%E9%A2%981.png" alt="image-20200731221210621"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 代码构造上图</span><br><span class="line"></span><br><span class="line">graph &#x3D; &#123;</span><br><span class="line">    &quot;A&quot;: &#123;&quot;B&quot;: 5, &quot;C&quot;: 1&#125;,</span><br><span class="line">    &quot;B&quot;: &#123;&quot;A&quot;: 5, &quot;C&quot;: 2, &quot;D&quot;: 1&#125;,</span><br><span class="line">    &quot;C&quot;: &#123;&quot;A&quot;: 1, &quot;B&quot;: 2, &quot;D&quot;: 4, &quot;E&quot;: 8&#125;,</span><br><span class="line">    &quot;D&quot;: &#123;&quot;B&quot;: 1, &quot;C&quot;: 4, &quot;E&quot;: 3, &quot;F&quot;: 6&#125;,</span><br><span class="line">    &quot;E&quot;: &#123;&quot;C&quot;: 8, &quot;D&quot;: 3&#125;,</span><br><span class="line">    &quot;F&quot;: &#123;&quot;D&quot;: 6&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/27</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dijkstra.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化各点距离值，起始点距离为0，其余点距离为正无穷大</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_distance</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    distance = &#123;start: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> vertex != start:</span><br><span class="line">            distance[vertex] = math.inf</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录未走过的点，使用优先队列维护，权重为起始点至当前节点的最短距离</span></span><br><span class="line">    pqueue = []</span><br><span class="line">    heapq.heappush(pqueue, (<span class="number">0</span>, start))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录已经被走过的点，set()用于去重</span></span><br><span class="line">    seen = set()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录当前节点的父节点，即从哪来的</span></span><br><span class="line">    parent = &#123;start: <span class="literal">None</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录从起始点到各节点的最短距离</span></span><br><span class="line">    distance = init_distance(graph, start)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找起始点至所有点的最短路径</span></span><br><span class="line">    <span class="keyword">while</span> pqueue:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 从起始点开始走。队列非空时，拿出队列中权重最小的点</span></span><br><span class="line">        pair = heapq.heappop(pqueue)</span><br><span class="line">        dist = pair[<span class="number">0</span>]</span><br><span class="line">        vertex = pair[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从队列中拿出的点，即认为被看见</span></span><br><span class="line">        seen.add(vertex)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从图中查看当前父节点的所有相邻子节点</span></span><br><span class="line">        nodes = graph[vertex].keys()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="comment"># 如果父节点到子节点的距离小于记录中的距离，则把子节点加入队列中，并更新子节点的距离值和子节点的父节点信息</span></span><br><span class="line">                <span class="keyword">if</span> dist + graph[vertex][node] &lt; distance[node]:</span><br><span class="line">                    heapq.heappush(pqueue, (dist + graph[vertex][node], node))</span><br><span class="line">                    distance[node] = dist + graph[vertex][node]</span><br><span class="line">                    parent[node] = vertex</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回溯最短路径</span></span><br><span class="line">    path = [end]</span><br><span class="line">    <span class="keyword">while</span> parent[path[<span class="number">0</span>]]:</span><br><span class="line">        path.insert(<span class="number">0</span>, parent[path[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path, distance[end]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    graph = &#123;</span><br><span class="line">	    <span class="string">&quot;A&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>: <span class="number">5</span>, <span class="string">&quot;C&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;B&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">5</span>, <span class="string">&quot;C&quot;</span>: <span class="number">2</span>, <span class="string">&quot;D&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;C&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">1</span>, <span class="string">&quot;B&quot;</span>: <span class="number">2</span>, <span class="string">&quot;D&quot;</span>: <span class="number">4</span>, <span class="string">&quot;E&quot;</span>: <span class="number">8</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;D&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>: <span class="number">1</span>, <span class="string">&quot;C&quot;</span>: <span class="number">4</span>, <span class="string">&quot;E&quot;</span>: <span class="number">3</span>, <span class="string">&quot;F&quot;</span>: <span class="number">6</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;E&quot;</span>: &#123;<span class="string">&quot;C&quot;</span>: <span class="number">8</span>, <span class="string">&quot;D&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;F&quot;</span>: &#123;<span class="string">&quot;D&quot;</span>: <span class="number">6</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    path, distance = dijkstra(graph, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">    print(path)</span><br><span class="line">    print(distance)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Programming</title>
    <url>/2020/08/27/Dynamic-Programming/</url>
    <content><![CDATA[<h2 id="Dynamic-Programming（动态规划）"><a href="#Dynamic-Programming（动态规划）" class="headerlink" title="Dynamic Programming（动态规划）"></a>Dynamic Programming（动态规划）</h2><p>解决重复子问题</p>
<h3 id="问题1：0-1背包问题"><a href="#问题1：0-1背包问题" class="headerlink" title="问题1：0/1背包问题"></a>问题1：0/1背包问题</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N &#x3D; 5</span><br><span class="line">V &#x3D; 10</span><br><span class="line">w &#x3D; [2, 2, 6, 5, 4]</span><br><span class="line">v &#x3D; [6, 3, 5, 4, 6]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="问题2：斐波那契数列"><a href="#问题2：斐波那契数列" class="headerlink" title="问题2：斐波那契数列"></a>问题2：斐波那契数列</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>求第n个斐波那契数</p>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/31</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_opt</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> rec_opt(n<span class="number">-1</span>) + rec_opt(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp_opt</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        opt = np.zeros(n, dtype=int)</span><br><span class="line">        opt[<span class="number">0</span>], opt[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            opt[i] = opt[i<span class="number">-1</span>] + opt[i<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> opt[n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        print(<span class="string">&#x27;=====第%s个数=====&#x27;</span> % (i))</span><br><span class="line">        print(<span class="string">&#x27;递归结果： %s&#x27;</span> % (rec_opt(i)))</span><br><span class="line">        print(<span class="string">&#x27;非递归结果： %s&#x27;</span> % (dp_opt(i)))</span><br><span class="line">        print(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="问题3：求最大和"><a href="#问题3：求最大和" class="headerlink" title="问题3：求最大和"></a>问题3：求最大和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>Array内，隔一个选一个，求最大和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr &#x3D; [1, 4, 6, 1, 9, 2, 2, 3]</span><br></pre></td></tr></table></figure>



<h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/31</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_opt</span>(<span class="params">arr, i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> max(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        A = rec_opt(arr, i<span class="number">-1</span>)</span><br><span class="line">        B = rec_opt(arr, i<span class="number">-2</span>) + arr[i]</span><br><span class="line">        <span class="keyword">return</span> max(A, B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp_opt</span>(<span class="params">arr, i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> max(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        opt = np.zeros(i+<span class="number">1</span>, dtype=int)</span><br><span class="line">        opt[<span class="number">0</span>] = arr[<span class="number">0</span>]</span><br><span class="line">        opt[<span class="number">1</span>] = max(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, i+<span class="number">1</span>):</span><br><span class="line">            A = opt[n<span class="number">-1</span>]</span><br><span class="line">            B = opt[n<span class="number">-2</span>] + arr[n]</span><br><span class="line">            opt[n] = max(A, B)</span><br><span class="line">        <span class="keyword">return</span> opt[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(rec_opt(arr, <span class="number">7</span>))</span><br><span class="line">    print(dp_opt(arr, <span class="number">7</span>))</span><br></pre></td></tr></table></figure>



<h3 id="问题4：是否可组成指定和"><a href="#问题4：是否可组成指定和" class="headerlink" title="问题4：是否可组成指定和"></a>问题4：是否可组成指定和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>数组Array（全是正整数），是否可以组成指定和S</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr &#x3D; [3, 34, 4, 12, 5, 2]</span><br><span class="line">S &#x3D; 9</span><br></pre></td></tr></table></figure>



<h4 id="python-2"><a href="#python-2" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/31</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_subset</span>(<span class="params">arr, i, S</span>):</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>] == S</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 剪枝</span></span><br><span class="line">    <span class="keyword">elif</span> arr[i] &gt; S:</span><br><span class="line">        <span class="keyword">return</span> rec_subset(arr, i<span class="number">-1</span>, S)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A = rec_subset(arr, i<span class="number">-1</span>, S-arr[i])</span><br><span class="line">        B = rec_subset(arr, i<span class="number">-1</span>, S)</span><br><span class="line">        <span class="keyword">return</span> A <span class="keyword">or</span> B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="comment">## 动态规划表：构造一个len(arr)行，S+1列的二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp_subset</span>(<span class="params">arr, S</span>):</span></span><br><span class="line">    subset = np.zeros((len(arr), S + <span class="number">1</span>), dtype=bool)</span><br><span class="line">    subset[:, <span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    subset[<span class="number">0</span>, :] = <span class="literal">False</span></span><br><span class="line">    subset[<span class="number">0</span>, arr[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">1</span>, S + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; s:</span><br><span class="line">                subset[i, s] = subset[i<span class="number">-1</span>, s]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = subset[i<span class="number">-1</span>, s-arr[i]]</span><br><span class="line">                B = subset[i<span class="number">-1</span>, s]</span><br><span class="line">                subset[i, s] = A <span class="keyword">or</span> B</span><br><span class="line">    <span class="keyword">return</span> subset[<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">3</span>, <span class="number">34</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">    print(dp_subset(arr, <span class="number">9</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">10</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">11</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">12</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter</title>
    <url>/2020/09/23/Jmeter/</url>
    <content><![CDATA[<p>The <strong>Apache JMeter™</strong> application is open source software, a 100% pure Java application designed to load test functional behavior and measure performance. It was originally designed for testing Web Applications but has since expanded to other test functions.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址：<a href="http://apache.mirrors.pair.com//jmeter/binaries/apache-jmeter-5.3.zip">http://apache.mirrors.pair.com//jmeter/binaries/apache-jmeter-5.3.zip</a></p>
<h3 id="Windows部署"><a href="#Windows部署" class="headerlink" title="Windows部署"></a>Windows部署</h3><h4 id="Java环境"><a href="#Java环境" class="headerlink" title="Java环境"></a>Java环境</h4><p>版本：jdk-8u131-windows-i586（链接：<a href="https://pan.baidu.com/s/1bBvyYNtrrzJTpFN9z0fnpg">https://pan.baidu.com/s/1bBvyYNtrrzJTpFN9z0fnpg</a> 提取码：4ztk）</p>
<p>系统环境变量：</p>
<ul>
<li>JAVA_HOME：C:\Program Files (x86)\Java\jdk1.8.0_131</li>
<li>CLASSPATH：.;%JAVA_HOME%\bin;%JAVA_HOME%\lib\dt.jar%JAVA_HOME%\lib\tools.jar;</li>
<li>PATH：新增两行，%JAVA_HOME%\bin，%JAVA_HOME%\jre\lib</li>
</ul>
<h4 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h4><p>开箱即用。可执行文件：<code>.\bin\jmeter.bat</code></p>
<h3 id="Linux部署"><a href="#Linux部署" class="headerlink" title="Linux部署"></a>Linux部署</h3><h4 id="Java环境-1"><a href="#Java环境-1" class="headerlink" title="Java环境"></a>Java环境</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<h4 id="Jmeter-1"><a href="#Jmeter-1" class="headerlink" title="Jmeter"></a>Jmeter</h4><p>环境变量<code>/etc/profile</code>增加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JMETER_HOME=/root/jmeter</span><br><span class="line">export CLASSPATH=$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$CLASSPATH</span><br><span class="line">export PATH=$JMETER_HOME/bin:$PATH:$HOME/bin</span><br></pre></td></tr></table></figure>

<p>环境变量配置生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmeter --version</span><br></pre></td></tr></table></figure>



<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>思路：</strong>通过Windows图形界面生成配置文件，上传至服务器进行压测</p>
<h3 id="http-https-性能测试"><a href="#http-https-性能测试" class="headerlink" title="http/https 性能测试"></a>http/https 性能测试</h3><h4 id="1-添加线程组"><a href="#1-添加线程组" class="headerlink" title="1. 添加线程组"></a>1. 添加线程组</h4><p>Test Plan中添加<code>Thread Group</code></p>
<p>总请求量 = 并发用户数 * 循环轮次</p>
<ul>
<li><p><code>Number of Threads (users)</code>：设置并发用户数</p>
</li>
<li><p><code>Loop Count</code>：设置循环轮次</p>
</li>
<li><p><code>Ramp-up period (seconds)</code>：设置压力启动时间（从开始到最大压力之间的时间）</p>
</li>
</ul>
<p><img src="/2020/09/23/Jmeter/jmeter-1.png" alt="jmeter-1"></p>
<p><img src="/2020/09/23/Jmeter/jmeter-2.png" alt="jmeter-2"></p>
<h4 id="2-设置http-https请求"><a href="#2-设置http-https请求" class="headerlink" title="2. 设置http/https请求"></a>2. 设置http/https请求</h4><p>Thread Group中添加<code>HTTP Request</code>，填写http/https请求的配置</p>
<p><img src="/2020/09/23/Jmeter/jmeter-3.png" alt="jmeter-3"></p>
<p><img src="/2020/09/23/Jmeter/jmeter-4.png" alt="jmeter-4"></p>
<h4 id="3-添加统计分析功能"><a href="#3-添加统计分析功能" class="headerlink" title="3. 添加统计分析功能"></a>3. 添加统计分析功能</h4><p>通常，添加如下两个统计分析功能：</p>
<ul>
<li>Summary Report</li>
<li>jp@gc - Transactions Per Second（需要单独安装，安装流程见插件 - QPS统计）</li>
</ul>
<p><img src="/2020/09/23/Jmeter/jmeter-5.png" alt="jmeter-5"></p>
<h4 id="4-导出配置"><a href="#4-导出配置" class="headerlink" title="4. 导出配置"></a>4. 导出配置</h4><p>保存jmx文件，上传至压力服务器。</p>
<h4 id="5-压力执行"><a href="#5-压力执行" class="headerlink" title="5. 压力执行"></a>5. 压力执行</h4><p>linux运行，生成结果文件至<code>test.jtl</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmeter -n -t vm.jmx -l test.jtl</span><br></pre></td></tr></table></figure>



<h4 id="6-查看性能测试结果"><a href="#6-查看性能测试结果" class="headerlink" title="6. 查看性能测试结果"></a>6. 查看性能测试结果</h4><p>下载<code>test.jtl</code>，在Windows Jmeter的统计分析功能中打开查看。</p>
<p><img src="/2020/09/23/Jmeter/jmeter-6.png" alt="jmeter-6"></p>
<p><img src="/2020/09/23/Jmeter/jmeter-7.png" alt="jmeter-7"></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><strong>Jmeter插件官网：</strong><a href="https://jmeter-plugins.org/wiki/Start/">https://jmeter-plugins.org/wiki/Start/</a></p>
<h3 id="QPS统计"><a href="#QPS统计" class="headerlink" title="QPS统计"></a>QPS统计</h3><p>下载地址：<a href="https://jmeter-plugins.org/files/packages/jpgc-graphs-basic-2.0.zip">https://jmeter-plugins.org/files/packages/jpgc-graphs-basic-2.0.zip</a></p>
<p>解压后，移动压缩包内lib目录下的文件至Jmeter\lib目录下同位置即可，重启Jmeter。</p>
<p><img src="/2020/09/23/Jmeter/jmeter-8.png" alt="jmeter-8"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://jmeter.apache.org/">Jmeter官方网站</a></p>
<p><a href="https://jmeter-plugins.org/wiki/Start/">Jmeter官方插件</a></p>
]]></content>
      <categories>
        <category>性能测试工具</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2020/09/10/Hexo/</url>
    <content><![CDATA[<h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。</p>
<p>Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>官方文档：<a href="https://hexo.bootcss.com/docs/">https://hexo.bootcss.com/docs/</a></p>
</blockquote>
<a id="more"></a>



<h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><h2 id="Hexo-GitHub"><a href="#Hexo-GitHub" class="headerlink" title="Hexo + GitHub"></a>Hexo + GitHub</h2><h2 id="Hexo-CMD"><a href="#Hexo-CMD" class="headerlink" title="Hexo CMD"></a>Hexo CMD</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init [folder]</span></span><br></pre></td></tr></table></figure>

<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.bootcss.com/docs/configuration.html">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>, <code>--deploy</code></td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>, <code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br></pre></td></tr></table></figure>

<h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo publish [layout] &lt;filename&gt;</span></span><br></pre></td></tr></table></figure>

<p>发表草稿。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--static</code></td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td align="left"><code>-l</code>, <code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy</span></span><br></pre></td></tr></table></figure>

<p>部署网站。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>, <code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>



<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo render &lt;file1&gt; [file2] ...</span></span><br></pre></td></tr></table></figure>

<p>渲染文件。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>, <code>--output</code></td>
<td align="left">设置输出路径</td>
</tr>
</tbody></table>
<h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo migrate &lt;<span class="built_in">type</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从其他博客系统 <a href="https://hexo.bootcss.com/docs/migration.html">迁移内容</a>。</p>
<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br></pre></td></tr></table></figure>

<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo list &lt;<span class="built_in">type</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>列出网站资料。</p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo version</span></span><br></pre></td></tr></table></figure>

<p>显示 Hexo 版本。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mosquitto</title>
    <url>/2020/08/31/Mosquitto/</url>
    <content><![CDATA[<h2 id="Mosquitto"><a href="#Mosquitto" class="headerlink" title="Mosquitto"></a>Mosquitto</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<a id="more"></a>

<p><img src="/2020/08/31/Mosquitto/1573118328615.png" alt="1573118328615"></p>
<h3 id="config-解析"><a href="#config-解析" class="headerlink" title="config 解析"></a>config 解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim mosquitto.conf</span><br><span class="line"></span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># General configuration</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 客户端心跳的间隔时间</span><br><span class="line">#retry_interval 20</span><br><span class="line"> </span><br><span class="line"># 系统状态的刷新时间</span><br><span class="line">#sys_interval 10</span><br><span class="line"> </span><br><span class="line"># 系统资源的回收时间，0表示尽快处理</span><br><span class="line">#store_clean_interval 10</span><br><span class="line"> </span><br><span class="line"># 服务进程的PID</span><br><span class="line">#pid_file &#x2F;var&#x2F;run&#x2F;mosquitto.pid</span><br><span class="line"> </span><br><span class="line"># 服务进程的系统用户</span><br><span class="line">#user mosquitto</span><br><span class="line"> </span><br><span class="line"># 客户端心跳消息的最大并发数</span><br><span class="line">#max_inflight_messages 10</span><br><span class="line"> </span><br><span class="line"># 客户端心跳消息缓存队列</span><br><span class="line">#max_queued_messages 100</span><br><span class="line"> </span><br><span class="line"># 用于设置客户端长连接的过期时间，默认永不过期</span><br><span class="line">#persistent_client_expiration</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Default listener</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 服务绑定的IP地址</span><br><span class="line">#bind_address</span><br><span class="line"> </span><br><span class="line"># 服务绑定的端口号</span><br><span class="line">#port 1883</span><br><span class="line"> </span><br><span class="line"># 允许的最大连接数，-1表示没有限制</span><br><span class="line">#max_connections -1</span><br><span class="line"> </span><br><span class="line"># cafile：CA证书文件</span><br><span class="line"># capath：CA证书目录</span><br><span class="line"># certfile：PEM证书文件</span><br><span class="line"># keyfile：PEM密钥文件</span><br><span class="line">#cafile</span><br><span class="line">#capath</span><br><span class="line">#certfile</span><br><span class="line">#keyfile</span><br><span class="line"> </span><br><span class="line"># 必须提供证书以保证数据安全性</span><br><span class="line">#require_certificate false</span><br><span class="line"> </span><br><span class="line"># 若require_certificate值为true，use_identity_as_username也必须为true</span><br><span class="line">#use_identity_as_username false</span><br><span class="line"> </span><br><span class="line"># 启用PSK（Pre-shared-key）支持</span><br><span class="line">#psk_hint</span><br><span class="line"> </span><br><span class="line"># SSL&#x2F;TSL加密算法，可以使用“openssl ciphers”命令获取</span><br><span class="line"># as the output of that command.</span><br><span class="line">#ciphers</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Persistence</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 消息自动保存的间隔时间</span><br><span class="line">#autosave_interval 1800</span><br><span class="line"> </span><br><span class="line"># 消息自动保存功能的开关</span><br><span class="line">#autosave_on_changes false</span><br><span class="line"> </span><br><span class="line"># 持久化功能的开关</span><br><span class="line">persistence true</span><br><span class="line"> </span><br><span class="line"># 持久化DB文件</span><br><span class="line">#persistence_file mosquitto.db</span><br><span class="line"> </span><br><span class="line"># 持久化DB文件目录</span><br><span class="line">#persistence_location &#x2F;var&#x2F;lib&#x2F;mosquitto&#x2F;</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Logging</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 4种日志模式：stdout、stderr、syslog、topic</span><br><span class="line"># none 则表示不记日志，此配置可以提升些许性能</span><br><span class="line">log_dest none</span><br><span class="line"> </span><br><span class="line"># 选择日志的级别（可设置多项）</span><br><span class="line">#log_type error</span><br><span class="line">#log_type warning</span><br><span class="line">#log_type notice</span><br><span class="line">#log_type information</span><br><span class="line"> </span><br><span class="line"># 是否记录客户端连接信息</span><br><span class="line">#connection_messages true</span><br><span class="line"> </span><br><span class="line"># 是否记录日志时间</span><br><span class="line">#log_timestamp true</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Security</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 客户端ID的前缀限制，可用于保证安全性</span><br><span class="line">#clientid_prefixes</span><br><span class="line"> </span><br><span class="line"># 允许匿名用户</span><br><span class="line">#allow_anonymous true</span><br><span class="line"> </span><br><span class="line"># 用户&#x2F;密码文件，默认格式：username:password</span><br><span class="line">#password_file</span><br><span class="line"> </span><br><span class="line"># PSK格式密码文件，默认格式：identity:key</span><br><span class="line">#psk_file</span><br><span class="line"> </span><br><span class="line"># pattern write sensor&#x2F;%u&#x2F;data</span><br><span class="line"># ACL权限配置，常用语法如下：</span><br><span class="line"># 用户限制：user &lt;username&gt;</span><br><span class="line"># 话题限制：topic [read|write] &lt;topic&gt;</span><br><span class="line"># 正则限制：pattern write sensor&#x2F;%u&#x2F;data</span><br><span class="line">#acl_file</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Bridges</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 允许服务之间使用“桥接”模式（可用于分布式部署）</span><br><span class="line">#connection &lt;name&gt;</span><br><span class="line">#address &lt;host&gt;[:&lt;port&gt;]</span><br><span class="line">#topic &lt;topic&gt; [[[out | in | both] qos-level] local-prefix remote-prefix]</span><br><span class="line"> </span><br><span class="line"># 设置桥接的客户端ID</span><br><span class="line">#clientid</span><br><span class="line"> </span><br><span class="line"># 桥接断开时，是否清除远程服务器中的消息</span><br><span class="line">#cleansession false</span><br><span class="line"> </span><br><span class="line"># 是否发布桥接的状态信息</span><br><span class="line">#notifications true</span><br><span class="line"> </span><br><span class="line"># 设置桥接模式下，消息将会发布到的话题地址</span><br><span class="line"># $SYS&#x2F;broker&#x2F;connection&#x2F;&lt;clientid&gt;&#x2F;state</span><br><span class="line">#notification_topic</span><br><span class="line"> </span><br><span class="line"># 设置桥接的keepalive数值</span><br><span class="line">#keepalive_interval 60</span><br><span class="line"> </span><br><span class="line"># 桥接模式，目前有三种：automatic、lazy、once</span><br><span class="line">#start_type automatic</span><br><span class="line"> </span><br><span class="line"># 桥接模式automatic的超时时间</span><br><span class="line">#restart_timeout 30</span><br><span class="line"> </span><br><span class="line"># 桥接模式lazy的超时时间</span><br><span class="line">#idle_timeout 60</span><br><span class="line"> </span><br><span class="line"># 桥接客户端的用户名</span><br><span class="line">#username</span><br><span class="line"> </span><br><span class="line"># 桥接客户端的密码</span><br><span class="line">#password</span><br><span class="line"> </span><br><span class="line"># bridge_cafile：桥接客户端的CA证书文件</span><br><span class="line"># bridge_capath：桥接客户端的CA证书目录</span><br><span class="line"># bridge_certfile：桥接客户端的PEM证书文件</span><br><span class="line"># bridge_keyfile：桥接客户端的PEM密钥文件</span><br><span class="line">#bridge_cafile</span><br><span class="line">#bridge_capath</span><br><span class="line">#bridge_certfile</span><br><span class="line">#bridge_keyfile</span><br><span class="line"> </span><br><span class="line"># 自己的配置可以放到以下目录中</span><br><span class="line">#include_dir &#x2F;mqtt&#x2F;config&#x2F;conf.d</span><br></pre></td></tr></table></figure>

<h3 id="Qos-解析"><a href="#Qos-解析" class="headerlink" title="Qos 解析"></a>Qos 解析</h3><h4 id="Qos-0-–-gt-最多一次"><a href="#Qos-0-–-gt-最多一次" class="headerlink" title="Qos=0 –&gt; 最多一次"></a>Qos=0 –&gt; 最多一次</h4><blockquote>
<p>sequenceDiagram</p>
<p>ClientA-&gt;&gt;ServerBroker: 发送消息<br>ServerBroker-&gt;&gt;ClientB: 发送消息</p>
</blockquote>
<h4 id="Qos-1-–-gt-至少一次"><a href="#Qos-1-–-gt-至少一次" class="headerlink" title="Qos=1 –&gt; 至少一次"></a>Qos=1 –&gt; 至少一次</h4><blockquote>
<p>sequenceDiagram</p>
<p>ClientA-&gt;&gt;ServerBroker: 1.发送消息PUBLISH<br>ServerBroker-&gt;&gt;ServerBroker: 1.1存储消息<br>ServerBroker-&gt;&gt;ClientA: 1.2发送消息回应PUBACK<br>ServerBroker-&gt;&gt;ClientB: 2.发送消息<br>ClientB-&gt;&gt;ServerBroker: 2.1发送消息回应PUBACK<br>ServerBroker-&gt;&gt;ServerBroker: 2.2删除消息</p>
</blockquote>
<h4 id="Qos-2-–-gt-有且仅有一次"><a href="#Qos-2-–-gt-有且仅有一次" class="headerlink" title="Qos=2 –&gt; 有且仅有一次"></a>Qos=2 –&gt; 有且仅有一次</h4><blockquote>
<p>sequenceDiagram</p>
<p>ClientA-&gt;&gt;ServerBroker: 1.发送消息PUBLISH<br>ServerBroker-&gt;&gt;ServerBroker: 1.1存储消息<br>ServerBroker-&gt;&gt;ClientA: 1.2发送消息回应Rec<br>ClientA-&gt;&gt;ServerBroker: 2.发送消息Rel<br>ServerBroker-&gt;&gt;ServerBroker: 2.1删除消息<br>ServerBroker-&gt;&gt;ServerBroker: 2.2存储消息到发送列队<br>ServerBroker-&gt;&gt;ClientB: 2.3发送消息<br>ServerBroker-&gt;&gt;ClientA: 2.4发送消息回应Comp<br>ClientB-&gt;&gt;ServerBroker: 3.发送消息回应Rec<br>ServerBroker-&gt;&gt;ServerBroker: 3.1删除2.2中存储的消息（一次确认）<br>ServerBroker-&gt;&gt;ServerBroker: 3.2存储消息<br>ServerBroker-&gt;&gt;ClientB: 3.3发送消息Rel<br>ClientB-&gt;&gt;ServerBroker: 3.4发送消息回应Comp<br>ServerBroker-&gt;&gt;ServerBroker: 3.5删除消息(二次确认)</p>
</blockquote>
<p><img src="/2020/08/31/Mosquitto/1573118624880.png" alt="1573118624880"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验1：Mosquitto-内存数据落盘机制"><a href="#实验1：Mosquitto-内存数据落盘机制" class="headerlink" title="实验1：Mosquitto 内存数据落盘机制"></a>实验1：Mosquitto 内存数据落盘机制</h4><h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>​    Mosquitto 内存数据落盘持久化时，是否会产生重复数据</p>
<h5 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h5><p>​    Mosquitto 不会重复持久化已经持久化过的数据</p>
<h5 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h5><p>​    mosquitto version 1.4.15</p>
<h5 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h5><ol>
<li>发送者保持同样的发送速率，降低订阅者消费速度，触发mqtt的持久化机制</li>
<li>更改mqtt持久化的间隔（3s 和 30s），观测持久化的数据大小是否不同</li>
</ol>
<h5 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h5><blockquote>
<p>发送者：发送1w条消息，用时 31.16837883 s</p>
<p>订阅者：每分钟消化1条，1min内堆积9999条消息</p>
<p>Mosquitto：持久化间隔 3s，1min内涨幅 27842 Byte</p>
</blockquote>
<p><img src="/2020/08/31/Mosquitto/1573112430542.png" alt="1573112430542"></p>
<blockquote>
<p>发送者：发送1w条消息，</p>
<p>订阅者：每分钟消化1条，1min内堆积9999条消息</p>
<p>Mosquitto：持久化间隔 30s，1min内涨幅 27842 Byte</p>
</blockquote>
<p><img src="/2020/08/31/Mosquitto/1573113441213.png" alt="1573113441213"></p>
<h5 id="实验脚本"><a href="#实验脚本" class="headerlink" title="实验脚本"></a>实验脚本</h5><h6 id="send-py"><a href="#send-py" class="headerlink" title="send.py"></a>send.py</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">Send msg to mqtt (linux, python2)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">__author__ &#x3D; &#39;RYB&#39;</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import paho.mqtt.publish as publish</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ranstr(num):</span><br><span class="line">    salt &#x3D; &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, num))</span><br><span class="line">    return salt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def publish_msg(msg_num):</span><br><span class="line">    for i in range(msg_num):</span><br><span class="line">        msg &#x3D; &#123;</span><br><span class="line">            &quot;id&quot;: i,</span><br><span class="line">            &quot;Timestamp&quot;: int(time.time() * 1000),</span><br><span class="line">            &quot;str1&quot;: ranstr(50),</span><br><span class="line">            &quot;str2&quot;: ranstr(50)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publish.single(&quot;test&quot;, payload&#x3D;json.dumps(msg), qos&#x3D;2, hostname&#x3D;&quot;10.244.0.164&quot;, port&#x3D;1883)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">print(&quot;Running...&quot;)</span><br><span class="line">publish_msg(10000)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; End &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">print(&quot;Run Time: %s s&quot; % str(end - start))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="rec-py"><a href="#rec-py" class="headerlink" title="rec.py"></a>rec.py</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">Receive msg from mqtt (linux, python2)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">__author__ &#x3D; &#39;RYB&#39;</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import paho.mqtt.subscribe as subscribe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def on_message_sleep(client, userdata, msg):</span><br><span class="line">    print(msg.topic + &#39; --&gt; &#39; + msg.payload)</span><br><span class="line">    time.sleep(60)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subscribe.callback(on_message_sleep, &quot;test&quot;, qos&#x3D;2, hostname&#x3D;&quot;mosquitto&quot;, port&#x3D;1883)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3>]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 11.2 安装文档</title>
    <url>/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="win10安装"><a href="#win10安装" class="headerlink" title="win10安装"></a>win10安装</h2><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>版本：Oracle 11.2.0.1.0</p>
<p>链接：<a href="https://pan.baidu.com/s/12ctlN7GaU4JbIOuawpsiqA">https://pan.baidu.com/s/12ctlN7GaU4JbIOuawpsiqA</a> </p>
<p>提取码：bah3</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><p>解压后，双击setup.exe。目录建议全英文</p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-1.png" alt="win10-1"></p>
<h4 id="环境检测"><a href="#环境检测" class="headerlink" title="环境检测"></a>环境检测</h4><p>双击setup.exe后，自动启动安装程序，检测环境配置。</p>
<p>我本次目的是测试安装流程，点击是继续安装即可。对安装无影响，对性能有影响。</p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-2.png" alt="win10-2"></p>
<h4 id="配置安全更新"><a href="#配置安全更新" class="headerlink" title="配置安全更新"></a>配置安全更新</h4><p>电子邮箱配置自己的即可，会接受安全问题通知，也可以不填</p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-3.png" alt="win10-3"></p>
<h4 id="安装选项"><a href="#安装选项" class="headerlink" title="安装选项"></a>安装选项</h4><p>选择创建和配置数据库，点击下一步</p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-4.png" alt="win10-4"></p>
<h4 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h4><p>这里在win10上实验，选择的桌面类</p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-5.png" alt="win10-5"></p>
<h4 id="典型安装"><a href="#典型安装" class="headerlink" title="典型安装"></a>典型安装</h4><p>设置数据库文件存储目录、数据库版本、字符集、数据库名及管理口令（用户名为<code>system</code>）</p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-6.png" alt="win10-6"></p>
<h4 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h4><p>典型安装完成后，按照流程下一步即可完成安装</p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>CMD：<code>sqlplus system/&lt;system password&gt;</code></p>
<p>网页：<code>https://localhost:1158/em</code>，用户名<code>system</code>，口令为典型安装中配置的管理口令</p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-8.png" alt="win10-8"></p>
<p><img src="/2020/09/10/Oracle-11-2-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/win10-7.png" alt="win10-7"></p>
<h2 id="Ubuntu-18-Docker安装"><a href="#Ubuntu-18-Docker安装" class="headerlink" title="Ubuntu 18 Docker安装"></a>Ubuntu 18 Docker安装</h2><h3 id="安装包-1"><a href="#安装包-1" class="headerlink" title="安装包"></a>安装包</h3><p>版本：Oracle Express Edition 11g Release 2</p>
<p>GitHub：<a href="https://github.com/wnameless/docker-oracle-xe-11g">https://github.com/wnameless/docker-oracle-xe-11g</a></p>
<h3 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><p>参考文档：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">https://www.runoob.com/docker/ubuntu-docker-install.html</a></p>
<p>安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>也可以使用国内 daocloud 一键安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>

<h4 id="安装Oracle-11G"><a href="#安装Oracle-11G" class="headerlink" title="安装Oracle 11G"></a>安装Oracle 11G</h4><h5 id="Installation-Local"><a href="#Installation-Local" class="headerlink" title="Installation(Local)"></a>Installation(Local)</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/wnameless/docker-oracle-xe-11g.git</span><br><span class="line">cd docker-oracle-xe-11g</span><br><span class="line">docker build -t wnameless/oracle-xe-11g .</span><br></pre></td></tr></table></figure>

<h5 id="Installation-DockerHub"><a href="#Installation-DockerHub" class="headerlink" title="Installation(DockerHub)"></a>Installation(DockerHub)</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull wnameless/oracle-xe-11g-r2</span><br></pre></td></tr></table></figure>

<p>SSH server has been removed since 18.04, please use “docker exec”</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>Run with 1521 port opened:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 49161:1521 wnameless/oracle-xe-11g-r2</span><br></pre></td></tr></table></figure>

<p>Run this, if you want the database to be connected remotely:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 49161:1521 -e ORACLE_ALLOW_REMOTE=true wnameless/oracle-xe-11g-r2</span><br></pre></td></tr></table></figure>

<h4 id="默认信息"><a href="#默认信息" class="headerlink" title="默认信息"></a>默认信息</h4><p>By default, the password verification is disable(password never expired)<br>Connect database with following setting:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostname: localhost</span><br><span class="line">port: 49161</span><br><span class="line">sid: xe</span><br><span class="line">username: system</span><br><span class="line">password: oracle</span><br></pre></td></tr></table></figure>

<p>Password for SYS &amp; SYSTEM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oracle</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle 11.2</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 11.2 快速上手</title>
    <url>/2020/09/14/Oracle-11-2-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<p>Oracle Database，又名Oracle RDBMS，简称Oracle。是甲骨文公司推出的一款关系数据库管理系统。Oracle数据库系统是目前世界上流行的关系数据库管理系统，拥有可移植性好、使用方便、功能强等优点，在各类大、中、小、微机环境中都适用。Oracle是一种高效率、可靠性好的、适应高吞吐量的数据库解决方案。</p>
<h3 id="Oracle-登录"><a href="#Oracle-登录" class="headerlink" title="Oracle 登录"></a>Oracle 登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式：sqlplus &lt;username&gt;/&lt;password&gt;[@ip:port/instance name] [as sysdba]</span></span><br><span class="line">sqlplus sys/123@10.121.9.104:49161 as sysdba</span><br></pre></td></tr></table></figure>



<h3 id="Oracle-用户管理"><a href="#Oracle-用户管理" class="headerlink" title="Oracle 用户管理"></a>Oracle 用户管理</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前用户</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改用户密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> &lt;username&gt; <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&quot;&lt;new password&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Oracle-数据库设置"><a href="#Oracle-数据库设置" class="headerlink" title="Oracle 数据库设置"></a>Oracle 数据库设置</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启时间统计</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空共享池</span></span><br><span class="line"><span class="comment">会清空历史sql的缓存记录，清空后再次执行这些sql时会产生大量的硬解析，影响数据库性能</span></span><br><span class="line"><span class="comment">生产环境慎用，系统繁忙时执行，容易导致数据库宕机</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">flush</span> <span class="keyword">shared_pool</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Oracle-表操作"><a href="#Oracle-表操作" class="headerlink" title="Oracle 表操作"></a>Oracle 表操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line">desc &lt;table name&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t</span><br><span class="line">(</span><br><span class="line">    tid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    tname <span class="built_in">varchar2</span>(<span class="number">20</span>),</span><br><span class="line">    tcontent <span class="built_in">blob</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表内容</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表，在垃圾桶留下记录，可flashback闪回</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span> <span class="keyword">name</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表，不会在垃圾桶留下记录，不可恢复</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span> <span class="keyword">name</span>&gt; <span class="keyword">purge</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Oracle-存储过程语法"><a href="#Oracle-存储过程语法" class="headerlink" title="Oracle 存储过程语法"></a>Oracle 存储过程语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> <span class="keyword">replace</span>] <span class="keyword">procedure</span> 存储过程名（param1 <span class="keyword">in</span> <span class="keyword">type</span>，param2 <span class="keyword">out</span> <span class="keyword">type</span>）</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">    变量<span class="number">1</span> 类型（值范围）;</span><br><span class="line">    变量2 类型（值范围）;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> 变量<span class="number">1</span> <span class="keyword">from</span> 表A <span class="keyword">where</span>列名=param1；</span><br><span class="line">    <span class="keyword">if</span> (判断条件) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">select</span> 列名 <span class="keyword">into</span> 变量<span class="number">2</span> <span class="keyword">from</span> 表A <span class="keyword">where</span>列名=param1；</span><br><span class="line">        dbms_output.Put_line(<span class="string">&#x27;打印信息&#x27;</span>);</span><br><span class="line">    elsif (判断条件) then</span><br><span class="line">        dbms_output.Put_line(&#x27;打印信息&#x27;);</span><br><span class="line">    else</span><br><span class="line">        raise 异常名（NO_DATA_FOUND）;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">exception</span><br><span class="line">    when others then</span><br><span class="line">        <span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://docs.oracle.com/cd/E11882_01/index.htm?xd_co_f=94201a14-f246-4e54-ba51-c48c9c02f224">Oracle 官方文档</a></p>
<p><a href="https://www.cnblogs.com/c1024/p/11012016.html">Oracle数据库初学者入门教程</a></p>
<p><a href="https://www.cnblogs.com/xswt/p/11394032.html">Oracle常用命令</a></p>
<p><a href="https://www.cnblogs.com/joeyJss/p/11458653.html">Oracle存储过程的语法</a></p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle 11.2</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 性能测试</title>
    <url>/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="使用Oracle-SQL测试"><a href="#使用Oracle-SQL测试" class="headerlink" title="使用Oracle SQL测试"></a>使用Oracle SQL测试</h2><blockquote>
<p>实验环境</p>
<p>机器：win10虚机</p>
<p>配置：4c8G + 500G硬盘</p>
</blockquote>
<h3 id="持续写入"><a href="#持续写入" class="headerlink" title="持续写入"></a>持续写入</h3><p>每次insert操作后，进行一次commit操作，性能低。<code>实验用时：00:02:39.66</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(x <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空共享池，注意在生产环境中千万不能做这步操作</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">flush</span> <span class="keyword">shared_pool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义函数proc</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> proc</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> .. <span class="number">1000000</span></span><br><span class="line">        <span class="keyword">loop</span></span><br><span class="line">            <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i);</span><br><span class="line">            <span class="keyword">commit</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启sql时间统计</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 运行函数proc</span></span><br><span class="line">exec proc;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E6%8C%81%E7%BB%AD%E5%86%99%E5%85%A5.png" alt="持续写入"></p>
<h3 id="批量写入"><a href="#批量写入" class="headerlink" title="批量写入"></a>批量写入</h3><p>对insert操作进行批量提交，性能相较于上者有所提升。<code>实验用时：00:01:25.37</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(x <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空共享池，注意在生产环境中千万不能做这步操作</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">flush</span> <span class="keyword">shared_pool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义函数proc</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> proc</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> .. <span class="number">1000000</span></span><br><span class="line">        <span class="keyword">loop</span></span><br><span class="line">            <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i);</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启sql时间统计</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 运行函数proc</span></span><br><span class="line">exec proc;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E6%89%B9%E9%87%8F%E5%86%99%E5%85%A5.png" alt="批量写入"></p>
<h3 id="connect-by方式写入"><a href="#connect-by方式写入" class="headerlink" title="connect by方式写入"></a>connect by方式写入</h3><p>Oracle提供的层次查询（Hierarchical Queries）功能中的connect by子句可以快速插入连续数字。该方法会将数据写入数据缓冲区(data buffer)中，然后刷入磁盘中。<code>实验用时：00:00:01.56</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(x <span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空共享池，注意在生产环境中千万不能做这步操作</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">flush</span> <span class="keyword">shared_pool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启sql时间统计</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用connect by level，插入连续数字</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E9%9B%86%E5%90%88%E5%86%99%E5%85%A5.png" alt="connect by写入"></p>
<h3 id="直接路径写入"><a href="#直接路径写入" class="headerlink" title="直接路径写入"></a>直接路径写入</h3><p>该方式跳过了数据缓冲区(data buffer)， 直接写进磁盘中，这种方式称之为直接路径读写方式。<code>实验用时：00:00:00.78</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空共享池，注意在生产环境中千万不能做这步操作</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">flush</span> <span class="keyword">shared_pool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启sql时间统计</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用connect by level，插入连续数字</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> x <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E7%9B%B4%E6%8E%A5%E8%B7%AF%E5%BE%84%E5%86%99%E5%85%A5.png" alt="直接路径写入"></p>
<h3 id="并行模式直接写入"><a href="#并行模式直接写入" class="headerlink" title="并行模式直接写入"></a>并行模式直接写入</h3><p>并行加直接路径，而且是不写日志。<code>实验用时：00:00:00.67</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空共享池，注意在生产环境中千万不能做这步操作</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">flush</span> <span class="keyword">shared_pool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启sql时间统计</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用connect by level，插入连续数字</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t nologging <span class="keyword">parallel</span> <span class="number">4</span> <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> x <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%86%99%E5%85%A5.png" alt="并行模式写入"></p>
<h3 id="大对象存储"><a href="#大对象存储" class="headerlink" title="大对象存储"></a>大对象存储</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t</span><br><span class="line">(</span><br><span class="line">    tid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    tname <span class="built_in">varchar2</span>(<span class="number">20</span>),</span><br><span class="line">    tcontent <span class="built_in">blob</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建普通序列号</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> sequ_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注册目录</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">directory</span> TEST_DIR <span class="keyword">as</span> <span class="string">&#x27;C:\Users\lenovo\Desktop&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 存储文件对象</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    tempimg <span class="built_in">blob</span>;  <span class="comment">-- 定义临时变量存放数据   </span></span><br><span class="line">    tempdir bfile := bfilename(&#x27;TEST_DIR&#x27;,&#x27;test.png&#x27;);  <span class="comment">-- 非常重要：DIR必须大写</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (sequ_t.nextval,<span class="string">&#x27;test.png&#x27;</span>,empty_blob())</span><br><span class="line">    <span class="keyword">returning</span> tcontent <span class="keyword">into</span> tempimg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 使用内置的包，给tempimg写入数据</span></span><br><span class="line">    dbms_lob.fileopen(tempdir);  <span class="comment">-- 打开指定文件</span></span><br><span class="line">    dbms_lob.loadfromfile(tempimg,tempdir,dbms_lob.getlength(tempdir));</span><br><span class="line">    dbms_lob.fileclose(tempdir);  <span class="comment">-- 关闭文件        </span></span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读取文件对象</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    l_file utl_file.file_type;  <span class="comment">-- 定义写入磁盘文件的类型和格式</span></span><br><span class="line">    l_buffer raw(32767);  <span class="comment">-- 定义缓冲区大小</span></span><br><span class="line">    l_amount binary_integer := 3276;  <span class="comment">-- 每次位移个数</span></span><br><span class="line">    l_pos int :=1;  <span class="comment">-- 开始位置</span></span><br><span class="line">    l_blob blob;  <span class="comment">-- 临时数据存放</span></span><br><span class="line">    l_blob_len int;  <span class="comment">-- 总长度</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 将数据库中的数据，存放在blob变量中  </span></span><br><span class="line">    <span class="keyword">select</span> tcontent <span class="keyword">into</span> l_blob <span class="keyword">from</span> t <span class="keyword">where</span> tname=<span class="string">&#x27;test.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 获取blob文件的长度</span></span><br><span class="line">    l_blob_len := dbms_lob.getlength(l_blob);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 准备写入磁盘文件</span></span><br><span class="line">    l_file := utl_file.fopen(&#x27;TEST_DIR&#x27;,&#x27;t.png&#x27;,&#x27;wb&#x27;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 写入数据</span></span><br><span class="line">    while l_pos&lt;l_blob_len</span><br><span class="line">    loop</span><br><span class="line">        dbms_lob.read(l_blob,l_amount,l_pos,l_buffer);</span><br><span class="line">        utl_file.put_raw(l_file,l_buffer,true);</span><br><span class="line">        l_pos := l_pos + l_amount;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    utl_file.fclose(l_file); </span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E5%AD%98%E5%82%A8image.png" alt="存储image"></p>
<p><img src="/2020/09/15/Oracle-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/%E8%AF%BB%E5%8F%96image.png" alt="读取image"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.oracle.com/database/121/ARPLS/d_lob.htm#ARPLS600">Oracle 官方文档：DBMS_LOB</a></p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort</title>
    <url>/2020/08/27/Sort/</url>
    <content><![CDATA[<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="算法1：冒泡排序"><a href="#算法1：冒泡排序" class="headerlink" title="算法1：冒泡排序"></a>算法1：冒泡排序</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><blockquote>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 [1]。</li>
</ol>
<p>参考资料：</p>
<ol>
<li>吕新平、刘宏铭．二级公共基础知识实战训练教程：西安交通大学出版社，2006.02：30页</li>
</ol>
</blockquote>
<a id="more"></a>

<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2020&#x2F;08&#x2F;01</span><br><span class="line"># @Author  : renyb</span><br><span class="line"># @File    : sort.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def bubble_sort(arr):</span><br><span class="line"></span><br><span class="line">    # 这个循环负责设置冒泡排序进行的次数</span><br><span class="line">    for i in range(len(arr) - 1):</span><br><span class="line"></span><br><span class="line">        # j为列表下标</span><br><span class="line">        for j in range(len(arr) - i - 1):  </span><br><span class="line">            if arr[j] &gt; arr[j + 1]:</span><br><span class="line">                arr[j], arr[j + 1] &#x3D; arr[j + 1], arr[j]</span><br><span class="line">    return arr</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [2,3,5,7,1,4,6,15,5,2,7,9,10,15,9,17,12]</span><br><span class="line">    print(bubble_sort(array))</span><br></pre></td></tr></table></figure>



<h3 id="算法2：选择排序"><a href="#算法2：选择排序" class="headerlink" title="算法2：选择排序"></a>算法2：选择排序</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕 [1]。</p>
<p>参考文档：</p>
<ol>
<li><p>Ajay Kumar．Data Structure for C Programming：Firewall Media，2004：268-270</p>
</li>
<li><p>Hosam M.Mahmoud．Sorting: A Distribution Theory：John Wiley&amp;Sons, Inc，2000：139-142</p>
</li>
</ol>
</blockquote>
<h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从数组的前n个中寻找最大值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_index</span>(<span class="params">arr, n</span>):</span></span><br><span class="line">    max_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt; arr[max_index]:</span><br><span class="line">            max_index = i</span><br><span class="line">    <span class="keyword">return</span> max_index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    i = len(arr)</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        max_index = find_max_index(arr, i)</span><br><span class="line">        arr[i<span class="number">-1</span>], arr[max_index] = arr[max_index], arr[i<span class="number">-1</span>]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(select_sort(arr))</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="算法3：插入排序"><a href="#算法3：插入排序" class="headerlink" title="算法3：插入排序"></a>算法3：插入排序</h3><h4 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌 [1]。</p>
<p>参考文档：</p>
<ol>
<li>（美）科尔曼等著；殷建平等译．算法导论．北京：机械工业出版社，2013：17-29</li>
</ol>
</blockquote>
<h4 id="python-2"><a href="#python-2" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将索引为i的数插入数组前半部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">arr, i</span>):</span></span><br><span class="line">    temp = arr[i]</span><br><span class="line">    <span class="keyword">while</span> arr[i<span class="number">-1</span>] &gt; temp:</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 防越界</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    arr[i] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        insert(arr, i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(insert_sort(arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="算法4：快速排序"><a href="#算法4：快速排序" class="headerlink" title="算法4：快速排序"></a>算法4：快速排序</h3><h4 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动 [1]。</p>
<p><img src="/2020/08/27/Sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p>
<p>一趟快速排序的算法是：</p>
<p>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</p>
<p>2）以第一个数组元素作为关键数据，赋值给<strong>key</strong>，即<strong>key</strong>=A[0]；</p>
<p>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于<strong>key</strong>的值A[j]，将A[j]和A[i]的值交换；</p>
<p>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于<strong>key</strong>的A[i]，将A[i]和A[j]的值交换；</p>
<p>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于<strong>key</strong>,4中A[i]不大于<strong>key</strong>的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<p>参考资料：</p>
<ol>
<li>陈雄达，关晓飞，殷俊锋，张华隆编．数学实验：同济大学出版社，2016.08：第135页</li>
</ol>
</blockquote>
<h4 id="python-3"><a href="#python-3" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/01</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : sort.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归 + 分而治之</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归入口及出口</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &gt;= <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选取基准值，也可以选取最后一个元素</span></span><br><span class="line">        mid = arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义基准值左右两侧的列表</span></span><br><span class="line">        left, right = [], []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从原始数组中移除基准值</span></span><br><span class="line">        arr.remove(mid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= mid:</span><br><span class="line">                right.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left.append(num)</span><br><span class="line">        <span class="keyword">return</span> quick_sort(left) + [mid] + quick_sort(right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(quick_sort(array))</span><br></pre></td></tr></table></figure>



<h3 id="算法5：堆排序"><a href="#算法5：堆排序" class="headerlink" title="算法5：堆排序"></a>算法5：堆排序</h3><h4 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作 [1]：</p>
<ul>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p><img src="/2020/08/27/Sort/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p>
<p>参考资料：</p>
<ol>
<li>Floyd, Robert W. (1964), “Algorithm 245 - Treesort 3”, Communications of the ACM, 7 (12): 701, doi:10.1145/355588.365103</li>
</ol>
</blockquote>
<h4 id="python-4"><a href="#python-4" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点间的索引关系：</span></span><br><span class="line"><span class="comment"># 节点：i</span></span><br><span class="line"><span class="comment"># 父节点：(i - 1) / 2</span></span><br><span class="line"><span class="comment"># 左子节点：2i + 1</span></span><br><span class="line"><span class="comment"># 右子节点：2i + 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">tree, n, i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    c1 = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    c2 = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    max = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c1 &lt; n <span class="keyword">and</span> tree[c1] &gt; tree[max]:</span><br><span class="line">        max = c1</span><br><span class="line">    <span class="keyword">if</span> c2 &lt; n <span class="keyword">and</span> tree[c2] &gt; tree[max]:</span><br><span class="line">        max = c2</span><br><span class="line">    <span class="keyword">if</span> max != i:</span><br><span class="line">        tree[max], tree[i] = tree[i], tree[max]</span><br><span class="line">        heapify(tree, n, max)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span>(<span class="params">tree, n</span>):</span></span><br><span class="line">    last_node = n - <span class="number">1</span></span><br><span class="line">    parent = (last_node - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> parent &gt;= <span class="number">0</span>:</span><br><span class="line">        heapify(tree, n, parent)</span><br><span class="line">        parent -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">tree</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建堆</span></span><br><span class="line">    n = len(tree)</span><br><span class="line">    build_heap(tree, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 第一个节点与最后一个节点交换</span></span><br><span class="line">        tree[<span class="number">0</span>], tree[n<span class="number">-1</span>] = tree[n<span class="number">-1</span>], tree[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 剩下的节点重新构建堆</span></span><br><span class="line">        build_heap(tree, n<span class="number">-1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    tree = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    heap_sort(tree)</span><br><span class="line">    print(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="算法6：归并排序"><a href="#算法6：归并排序" class="headerlink" title="算法6：归并排序"></a>算法6：归并排序</h3><h4 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>归并操作，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。</p>
<p>如　设有数列{6，202，100，301，38，8，1}</p>
<p>初始状态：6,202,100,301,38,8,1</p>
<p>第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；</p>
<p>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；</p>
<p>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；</p>
<p>总的比较次数为：3+4+4=11；</p>
<p>逆序数为14；</p>
<p><img src="/2020/08/27/Sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p>
<p>归并操作的工作原理如下：</p>
<p>第一步：申请空间，使其大小为两个已经<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F">排序</a>序列之和，该空间用来存放合并后的序列</p>
<p>第二步：设定两个<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，最初位置分别为两个已经排序序列的起始位置</p>
<p>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
<p>重复步骤3直到某一指针超出序列尾</p>
<p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</blockquote>
<h4 id="python-5"><a href="#python-5" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将左右两个数组合并</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定两个指针，分别指向左右两个数组的开始位置</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并后的数组</span></span><br><span class="line">    record = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左右两个数组均未被遍历完</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            record.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            record.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果左右两个数组有一个遍历完，将另一个剩余元素添加至record尾部</span></span><br><span class="line">    record += left[i:]</span><br><span class="line">    record += right[j:]</span><br><span class="line">    <span class="keyword">return</span> record</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归 + 分治</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 数组从中间切分</span></span><br><span class="line">    i = len(arr) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(arr[:i])</span><br><span class="line">    right = merge_sort(arr[i:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(merge_sort(arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle Performance Test：SwingBench</title>
    <url>/2020/09/18/SwingBench/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SwingBench是Oracle UK的一个员工在一个被抛弃的项目的基础上开发的。目前稳定版本2.6，基于JDK。该工具是免费的，可以在作者的网站上自由下载，并且拥有详细的使用文档。Swingbench 可以执行4种不同的标准测试(benchmark)，拥有三种前端展示方式Swingbench/Charbench/Minibench，其中 Charbench是字符模式的，另外两种是GUI模式的。另外还可以通过ClusterOverview可以聚合显示所有的结果。Swingbench 的开发目的主要是用来展示RAC的负载和测试，但也可用于单实例环境。2.3版本开始支持TimesTen。</p>
<blockquote>
<p>SwingBench consists of a load generator, a coordinator and a cluster overview. The software enables a load to be generated and the transactions/response times to be charted.</p>
<p>Swingbench can be used to demonstrate and test technologies such as Real Application Clusters, Online table rebuilds, Standby databases, Online backup and recovery etc.</p>
<p>The code that ships with SwingBench includes 6 benchmarks, OrderEntry, SalesHistory, TPC-DS Like, JSON, CallingCircle and StressTest..</p>
<ul>
<li>OrderEntry is based on the “oe” schema that ships with Oracle 12c/Oracle 18c/Oracle 19c. It has been modified so that Spatial, Intermedia schema’s do not need to be installed. It can be run continuously (that is until you run out of space). It introduces heavy contention on a small number of tables and is designed to stress interconnects and memory. It is installed using the “oewizard” located in the bin directory. Both a pure jdbc and pl/sql (lower network overhead) variant exist of the benchmark.</li>
<li>SalesHistory is based on the “sh” schema that ships with Oracle 12c/Oracle 18c/Oracle 19c and is designed to test the performance of complicated queries when run against large tables. It is read only and can be scaled over a number of default sizes from 1GB to 1TB. A custom mode also allows for the creation of smaller and larger schemas</li>
<li>CallingCircle (deprecated) simulates the SQL that is generated for an online telco application. It requires data files to be generated and copied from the database server to the load generator before each run, it typically requires between 1 and 8 GB of disk space. Both benchmarks are heavily CPU intensive. Experience has shown that you require at least 1 processor of load generator to every 2 processors of database server. It is designed to stress the CPU and memory without the need for a powerful I/O subsystem. Its is installed using the “ccwizard” located in the bin directory</li>
<li>StressTest simply fires random inserts,updates,selects and updates against a well know table.</li>
<li>JSON Stresstest is based on simple JSON documents modelling people flying between airports. It follow a basic CRUD model</li>
<li>TPC-DS Like Benchmark is a benchmark similar to TPC-DS. It features both a query and transaction workload in separate configuration files.</li>
</ul>
<p>The entire framework is developed in Java and as a result can be run on wide variety of platforms. It also provides a simple API to allow developers to build their own benchmarks.</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>系统：win10虚机</p>
<p>配置：4c8g，500G硬盘</p>
<h3 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h3><p>官方下载地址：<a href="http://www.dominicgiles.com/downloads.html">http://www.dominicgiles.com/downloads.html</a></p>
<h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><h4 id="安装JDK-1-8"><a href="#安装JDK-1-8" class="headerlink" title="安装JDK 1.8"></a>安装JDK 1.8</h4><p>版本：jdk-8u131-windows-i586（链接：<a href="https://pan.baidu.com/s/1bBvyYNtrrzJTpFN9z0fnpg">https://pan.baidu.com/s/1bBvyYNtrrzJTpFN9z0fnpg</a> 提取码：4ztk）</p>
<p>系统环境变量：</p>
<ul>
<li>JAVA_HOME：C:\Program Files (x86)\Java\jdk1.8.0_131</li>
<li>CLASSPATH：.;%JAVA_HOME%\bin;%JAVA_HOME%\lib\dt.jar%JAVA_HOME%\lib\tools.jar;</li>
<li>PATH：新增两行，%JAVA_HOME%\bin，%JAVA_HOME%\jre\lib</li>
</ul>
<h4 id="安装SwingBench"><a href="#安装SwingBench" class="headerlink" title="安装SwingBench"></a>安装SwingBench</h4><p>Swingbench压缩包下载完，解压即可使用。</p>
<h2 id="Oewizard加载数据"><a href="#Oewizard加载数据" class="headerlink" title="Oewizard加载数据"></a>Oewizard加载数据</h2><h3 id="运行Oewizard"><a href="#运行Oewizard" class="headerlink" title="运行Oewizard"></a>运行Oewizard</h3><p>进入<code>.\swingbench\winbin</code>目录下，双击运行<code>oewizard.bat</code>。</p>
<blockquote>
<p>实验时，出现双击后无响应的情况，在cmd中运行<code>oewizard.bat</code>文件，报错如下：<br>Error occurred during initialization of VM<br>Could not reserve enough space for 2097152KB object heap</p>
<p>解决方式：系统环境变量中添加如下变量<br>变量名：<code>JAVA_TOOL_OPTIONS</code>    变量值：<code>-Xms1024m</code><br>变量名：<code>_JAVA_OPTIONS</code>    变量值：<code>-Xmx1024m</code></p>
</blockquote>
<p><img src="/2020/09/18/SwingBench/oewizard-1.png" alt="oewizard-1"></p>
<h3 id="Benchmark-Version"><a href="#Benchmark-Version" class="headerlink" title="Benchmark Version"></a>Benchmark Version</h3><p>选择默认选项，version 2.0</p>
<p><img src="/2020/09/18/SwingBench/oewizard-2.png" alt="oewizard-2"></p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>选择默认选项，Create the Order Entry Schema (User, Table, indexes, Data etc)</p>
<p><img src="/2020/09/18/SwingBench/oewizard-3.png" alt="oewizard-3"></p>
<h3 id="Database-Details"><a href="#Database-Details" class="headerlink" title="Database Details"></a>Database Details</h3><p>填写Oracle数据库的连接信息</p>
<ul>
<li><p>Connect String：格式为<code>ip[：port][：service name]</code>，eg：<code>10.121.9.104:49161</code></p>
</li>
<li><p>Connection Type：使用默认选项，<code>Type IV jdbc driver (Thin)</code></p>
</li>
<li><p>Administrator Username：<code>sys as sysdba</code></p>
</li>
<li><p>Administrator Password：使用sys的密码，如果未设置，可在oracle中使用如下命令设置</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">sys</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&quot;&lt;new password&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/18/SwingBench/oewizard-4.png" alt="oewizard-4"></p>
<h3 id="Schema-Details"><a href="#Schema-Details" class="headerlink" title="Schema Details"></a>Schema Details</h3><ul>
<li><p>Username：<code>sys as sysdba</code></p>
</li>
<li><p>Password：sys的密码</p>
</li>
<li><p>Schema’s Tablespace：使用的是SYSTEM</p>
</li>
<li><p>Tablespaces’s Datafile：自动生成</p>
</li>
</ul>
<p><img src="/2020/09/18/SwingBench/oewizard-5.png" alt="oewizard-5"></p>
<h3 id="Database-Options"><a href="#Database-Options" class="headerlink" title="Database Options"></a>Database Options</h3><p>全使用默认选项，直接下一步</p>
<ul>
<li><p>Partitioning Model：<code>No Partitioning</code></p>
</li>
<li><p>Compression Used：<code>No Compression</code></p>
</li>
<li><p>Tablespace Type：<code>Bigfile Tablespace</code></p>
</li>
<li><p>Indexing Used：<code>All Indexes</code></p>
</li>
</ul>
<p><img src="/2020/09/18/SwingBench/oewizard-6.png" alt="oewizard-6"></p>
<h3 id="Sizing-Details"><a href="#Sizing-Details" class="headerlink" title="Sizing Details"></a>Sizing Details</h3><p>加载的测试数据大小，根据需求选择。实验选择的最小数据量1GB，点击下一步</p>
<p><img src="/2020/09/18/SwingBench/oewizard-7.png" alt="oewizard-7"></p>
<h3 id="ALL-Details-Entered"><a href="#ALL-Details-Entered" class="headerlink" title="ALL Details Entered"></a>ALL Details Entered</h3><p>Level of Parallelism：设置导入时的并发，只影响数据导入速度，默认为4</p>
<p><img src="/2020/09/18/SwingBench/oewizard-8.png" alt="oewizard-8"></p>
<h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p><img src="/2020/09/18/SwingBench/Swingbench%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.png" alt="Swingbench加载测试数据"></p>
<p><img src="/2020/09/18/SwingBench/Swingbench%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%EF%BC%88%E5%AE%8C%E6%88%90%EF%BC%89.png" alt="Swingbench加载测试数据（完成）"></p>
<h2 id="SwingBench性能测试"><a href="#SwingBench性能测试" class="headerlink" title="SwingBench性能测试"></a>SwingBench性能测试</h2><h3 id="开启SwingBench"><a href="#开启SwingBench" class="headerlink" title="开启SwingBench"></a>开启SwingBench</h3><p>进入<code>.\swingbench\winbin</code>目录下，双击运行<code>swingbench.bat</code>。界面功能区分布如下：</p>
<p><img src="/2020/09/18/SwingBench/swingbench-1.png" alt="swingbench-1"></p>
<h3 id="User-Details"><a href="#User-Details" class="headerlink" title="User Details"></a>User Details</h3><p>设置Oracle数据库的连接信息。<code>注意：必须使用sysdba用户，普通用户获取不到数据库的性能数据</code></p>
<ul>
<li>Username：<code>sys as sysdba</code></li>
<li>Password：sys的密码</li>
<li>Connect String：格式为<code>ip[：port][：service name]</code>，eg：<code>10.121.9.104:49161</code></li>
<li>Driver Type：使用默认选项，<code>Oracle jdbc Driver</code></li>
</ul>
<p>填写完成后，进行连接测试，提示如下则表明连接正常</p>
<p><img src="/2020/09/18/SwingBench/swingbench-4.png" alt="swingbench-4"></p>
<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>设置压力参数</p>
<ul>
<li>Number of Users：并发数，默认为4</li>
<li>Benchmark Run Time (hh:min)：运行时长</li>
</ul>
<h3 id="Server-Monitoring（ssh）"><a href="#Server-Monitoring（ssh）" class="headerlink" title="Server Monitoring（ssh）"></a>Server Monitoring（ssh）</h3><p>设置Oracle主机的ssh信息，SwingBench会ssh到主机，获取监控信息</p>
<p><img src="/2020/09/18/SwingBench/swingbench-2.png" alt="swingbench-2"></p>
<h3 id="Oracle-AWR静态分析"><a href="#Oracle-AWR静态分析" class="headerlink" title="Oracle AWR静态分析"></a>Oracle AWR静态分析</h3><ul>
<li>勾选Connect database statistics</li>
<li>勾选Take AWR Snapshots at Start and End</li>
<li>Admin Username：<code>sys as sysdba</code></li>
<li>Admin Password：sys的密码</li>
</ul>
<h3 id="性能图表"><a href="#性能图表" class="headerlink" title="性能图表"></a>性能图表</h3><p>支持的图表如下</p>
<p><img src="/2020/09/18/SwingBench/swingbench-5.png" alt="swingbench-5"></p>
<h3 id="运行SwingBench"><a href="#运行SwingBench" class="headerlink" title="运行SwingBench"></a>运行SwingBench</h3><p><img src="/2020/09/18/SwingBench/swingbench-3.png" alt="swingbench-3"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.dominicgiles.com/simplebenchmark.html">SwingBench官方文档</a></p>
<p><a href="https://www.cnblogs.com/liangqihui/p/7193956.html">如何使用swingbench进行oracle数据库压力测试</a></p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>TiDB 安装文档</title>
    <url>/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>官方文档：<a href="https://docs.pingcap.com/zh/tidb/stable/production-deployment-using-tiup">https://docs.pingcap.com/zh/tidb/stable/production-deployment-using-tiup</a></p>
<h2 id="使用-TiUP-部署-TiDB-集群"><a href="#使用-TiUP-部署-TiDB-集群" class="headerlink" title="使用 TiUP 部署 TiDB 集群"></a>使用 TiUP 部署 TiDB 集群</h2><p><a href="https://github.com/pingcap/tiup">TiUP</a> 是 TiDB 4.0 版本引入的集群运维工具，<a href="https://github.com/pingcap/tiup/tree/master/components/cluster">TiUP cluster</a> 是 TiUP 提供的使用 Golang 编写的集群管理组件，通过 TiUP cluster 组件就可以进行日常的运维工作，包括部署、启动、关闭、销毁、弹性扩缩容、升级 TiDB 集群；管理 TiDB 集群参数。</p>
<p>目前 TiUP 可以支持部署 TiDB、TiFlash、TiDB Binlog、TiCDC，以及监控系统。本文将介绍不同集群拓扑的具体部署步骤。</p>
<h3 id="第-1-步：软硬件环境需求及前置检查"><a href="#第-1-步：软硬件环境需求及前置检查" class="headerlink" title="第 1 步：软硬件环境需求及前置检查"></a>第 1 步：软硬件环境需求及前置检查</h3><p><a href="https://docs.pingcap.com/zh/tidb/stable/hardware-and-software-requirements">软硬件环境需求</a></p>
<p><a href="https://docs.pingcap.com/zh/tidb/stable/check-before-deployment">环境与系统配置检查</a></p>
<h3 id="第-2-步：在中控机上安装-TiUP-组件"><a href="#第-2-步：在中控机上安装-TiUP-组件" class="headerlink" title="第 2 步：在中控机上安装 TiUP 组件"></a>第 2 步：在中控机上安装 TiUP 组件</h3><p>使用普通用户登录中控机，以 <code>tidb</code> 用户为例，后续安装 TiUP 及集群管理操作均通过该用户完成：</p>
<ol>
<li><p>执行如下命令安装 TiUP 工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh | sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>按如下步骤设置 TiUP 环境变量：</p>
<p>重新声明全局环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure>

<p>确认 TiUP 工具是否安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which tiup</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 TiUP cluster 组件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup cluster</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果已经安装，则更新 TiUP cluster 组件至最新版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup update --self &amp;&amp; tiup update cluster</span><br></pre></td></tr></table></figure>

<p>预期输出 <code>“Update successfully!”</code> 字样。</p>
</li>
<li><p>验证当前 TiUP cluster 版本信息。执行如下命令查看 TiUP cluster 组件版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup --binary cluster</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="第-3-步：编辑初始化配置文件"><a href="#第-3-步：编辑初始化配置文件" class="headerlink" title="第 3 步：编辑初始化配置文件"></a>第 3 步：编辑初始化配置文件</h3><p>请根据不同的集群拓扑，编辑 TiUP 所需的集群初始化配置文件。</p>
<p>这里举出常见的 6 种场景，请根据链接中的拓扑说明，以及给出的配置文件模板，新建一个配置文件 <code>topology.yaml</code>。如果有其他组合场景的需求，请根据多个模板自行调整。</p>
<ul>
<li><p><a href="https://docs.pingcap.com/zh/tidb/stable/minimal-deployment-topology">最小拓扑架构</a></p>
<p>最基本的集群拓扑，包括 tidb-server、tikv-server、pd-server，适合 OLTP 业务。</p>
</li>
<li><p><a href="https://docs.pingcap.com/zh/tidb/stable/tiflash-deployment-topology">增加 TiFlash 拓扑架构</a></p>
<p>包含最小拓扑的基础上，同时部署 TiFlash。TiFlash 是列式的存储引擎，已经逐步成为集群拓扑的标配。适合 Real-Time HTAP 业务。</p>
</li>
<li><p><a href="https://docs.pingcap.com/zh/tidb/stable/ticdc-deployment-topology">增加 TiCDC 拓扑架构</a></p>
<p>包含最小拓扑的基础上，同时部署 TiCDC。TiCDC 是 4.0 版本开始支持的 TiDB 增量数据同步工具，支持多种下游 (TiDB/MySQL/MQ)。相比于 TiDB Binlog，TiCDC 有延迟更低、天然高可用等优点。在部署完成后，需要启动 TiCDC，<a href="https://docs.pingcap.com/zh/tidb/stable/manage-ticdc">通过 <code>cdc cli</code> 创建同步任务</a>。</p>
</li>
<li><p><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-binlog-deployment-topology">增加 TiDB Binlog 拓扑架构</a></p>
<p>包含最小拓扑的基础上，同时部署 TiDB Binlog。TiDB Binlog 是目前广泛使用的增量同步组件，可提供准实时备份和同步功能。</p>
</li>
<li><p><a href="https://docs.pingcap.com/zh/tidb/stable/tispark-deployment-topology">增加 TiSpark 拓扑架构</a></p>
<p>包含最小拓扑的基础上，同时部署 TiSpark 组件。TiSpark 是 PingCAP 为解决用户复杂 OLAP 需求而推出的产品。TiUP cluster 组件对 TiSpark 的支持目前为实验性特性。</p>
</li>
<li><p><a href="https://docs.pingcap.com/zh/tidb/stable/hybrid-deployment-topology">混合部署拓扑架构</a></p>
<p>适用于单台机器，混合部署多个实例的情况，也包括单机多实例，需要额外增加目录、端口、资源配比、label 等配置。</p>
</li>
<li><p><a href="https://docs.pingcap.com/zh/tidb/stable/geo-distributed-deployment-topology">跨机房部署拓扑架构</a></p>
<p>以典型的 <code>两地三中心</code> 架构为例，介绍跨机房部署架构，以及需要注意的关键设置。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>topology.yaml</code>配置文件内不能使用主机名，需要使用ip地址。使用主机名会在启动时出现报错。</li>
<li>对于需要全局生效的参数，请在配置文件中 <code>server_configs</code> 的对应组件下配置。</li>
<li>对于需要某个节点生效的参数，请在具体节点的 <code>config</code> 中配置。</li>
<li>配置的层次结构使用 <code>.</code> 表示。如：<code>log.slow-threshold</code>。更多格式参考 <a href="https://github.com/pingcap/tiup/blob/master/examples/topology.example.yaml">TiUP 配置参数模版</a>。</li>
<li>更多参数说明，请参考 <a href="https://github.com/pingcap/tidb/blob/master/config/config.toml.example">TiDB <code>config.toml.example</code></a>、<a href="https://github.com/tikv/tikv/blob/master/etc/config-template.toml">TiKV <code>config.toml.example</code></a> 、 <a href="https://github.com/pingcap/pd/blob/master/conf/config.toml">PD <code>config.toml.example</code></a> 和 <a href="https://docs.pingcap.com/zh/tidb/stable/tiflash-configuration">TiFlash 配置参数</a>。</li>
</ul>
</blockquote>
<h3 id="第-4-步：执行部署命令"><a href="#第-4-步：执行部署命令" class="headerlink" title="第 4 步：执行部署命令"></a>第 4 步：执行部署命令</h3><blockquote>
<p><strong>注意：</strong></p>
<p>通过 TiUP 进行集群部署可以使用密钥或者交互密码方式来进行安全认证：</p>
<ul>
<li>如果是密钥方式，可以通过 <code>-i</code> 或者 <code>--identity_file</code> 来指定密钥的路径；</li>
<li>如果是密码方式，可以通过 <code>-p</code> 进入密码交互窗口；</li>
<li>如果已经配置免密登陆目标机，则不需填写认证。</li>
</ul>
<p>一般情况下 TiUP 会在目标机器上创建 <code>topology.yaml</code> 中约定的用户和组，以下情况例外：</p>
<ul>
<li><code>topology.yaml</code> 中设置的用户名在目标机器上已存在。</li>
<li>在命令行上使用了参数 <code>--skip-create-user</code> 明确指定跳过创建用户的步骤。</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup cluster deploy tidb-test v4.0.0 ./topology.yaml --user root [-p] [-i /home/root/.ssh/gcp_rsa]</span><br></pre></td></tr></table></figure>

<p>以上部署命令中：</p>
<ul>
<li>通过 TiUP cluster 部署的集群名称为 <code>tidb-test</code></li>
<li>部署版本为 <code>v4.0.0</code>，最新版本可以通过执行 <code>tiup list tidb</code> 来查看 TiUP 支持的版本</li>
<li>初始化配置文件为 <code>topology.yaml</code></li>
<li>–user root：通过 root 用户登录到目标主机完成集群部署，该用户需要有 ssh 到目标机器的权限，并且在目标机器有 sudo 权限。也可以用其他有 ssh 和 sudo 权限的用户完成部署。</li>
<li>[-i] 及 [-p]：非必选项，如果已经配置免密登陆目标机，则不需填写。否则选择其一即可，[-i] 为可登录到目标机的 root 用户（或 –user 指定的其他用户）的私钥，也可使用 [-p] 交互式输入该用户的密码</li>
<li>如果需要指定在目标机创建的用户组名，可以参考<a href="https://github.com/pingcap/tiup/blob/master/examples/topology.example.yaml#L7">这个例子</a>。</li>
</ul>
<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-1.png" alt="TiUP-1"></p>
<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-2.png" alt="TiUP-2"></p>
<p>预期日志结尾输出会有 <code>Deployed cluster </code>tidb-test<code> successfully</code> 关键词，表示部署成功。</p>
<h3 id="第-5-步：查看-TiUP-管理的集群情况"><a href="#第-5-步：查看-TiUP-管理的集群情况" class="headerlink" title="第 5 步：查看 TiUP 管理的集群情况"></a>第 5 步：查看 TiUP 管理的集群情况</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup cluster list</span><br></pre></td></tr></table></figure>

<p>TiUP 支持管理多个 TiDB 集群，该命令会输出当前通过 TiUP cluster 管理的所有集群信息，包括集群名称、部署用户、版本、密钥信息等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting &#x2F;home&#x2F;tidb&#x2F;.tiup&#x2F;components&#x2F;cluster&#x2F;v1.0.0&#x2F;cluster list</span><br><span class="line">Name              User  Version        Path                                                        PrivateKey</span><br><span class="line">----              ----  -------        ----                                                        ----------</span><br><span class="line">tidb-test         tidb  v4.0.0      &#x2F;home&#x2F;tidb&#x2F;.tiup&#x2F;storage&#x2F;cluster&#x2F;clusters&#x2F;tidb-test         &#x2F;home&#x2F;tidb&#x2F;.tiup&#x2F;storage&#x2F;cluster&#x2F;clusters&#x2F;tidb-test&#x2F;ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-3.png" alt="TiUP-3"></p>
<h3 id="第-6-步：检查部署的-TiDB-集群情况"><a href="#第-6-步：检查部署的-TiDB-集群情况" class="headerlink" title="第 6 步：检查部署的 TiDB 集群情况"></a>第 6 步：检查部署的 TiDB 集群情况</h3><p>例如，执行如下命令检查 <code>tidb-test</code> 集群情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup cluster display tidb-test</span><br></pre></td></tr></table></figure>

<p>预期输出包括 <code>tidb-test</code> 集群中实例 ID、角色、主机、监听端口和状态（由于还未启动，所以状态为 Down/inactive）、目录信息。</p>
<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-4.png" alt="TiUP-4"></p>
<h3 id="第-7-步：启动集群"><a href="#第-7-步：启动集群" class="headerlink" title="第 7 步：启动集群"></a>第 7 步：启动集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup cluster start tidb-test</span><br></pre></td></tr></table></figure>

<p>预期结果输出 <code>Started cluster </code>tidb-test<code> successfully</code> 标志启动成功。</p>
<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-5.png" alt="TiUP-5"></p>
<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-6.png" alt="TiUP-6"></p>
<h3 id="第-8-步：验证集群运行状态"><a href="#第-8-步：验证集群运行状态" class="headerlink" title="第 8 步：验证集群运行状态"></a>第 8 步：验证集群运行状态</h3><ul>
<li>通过 TiUP 检查集群状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tiup cluster display tidb-test</span><br></pre></td></tr></table></figure>

<p>预期结果输出，注意 Status 状态信息为 <code>Up</code> 说明集群状态正常</p>
<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-7.png" alt="TiUP-7"></p>
<ul>
<li>执行如下命令登录数据库：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -h 10.0.1.4 -P 4000</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/16/TiDB-%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/tiup-8.png" alt="TiUP-8"></p>
<p>此外，也需要验证监控系统、<a href="https://docs.pingcap.com/zh/tidb/stable/dashboard-intro">TiDB Dashboard</a> 的运行状态，以及简单命令的执行，验证方式可参考<a href="https://docs.pingcap.com/zh/tidb/stable/post-installation-check">验证集群运行状态</a>。</p>
<h3 id="TiUP管理命令"><a href="#TiUP管理命令" class="headerlink" title="TiUP管理命令"></a>TiUP管理命令</h3><h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看集群列表</span></span><br><span class="line">tiup cluster list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群状态</span></span><br><span class="line">tiup cluster display tidb-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动集群</span></span><br><span class="line">tiup cluster start tidb-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止集群</span></span><br><span class="line">tiup cluster stop tidb-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改集群参数</span></span><br><span class="line">tiup cluster edit-config tidb-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除集群</span></span><br><span class="line">tiup cluster destroy tidb-test</span><br></pre></td></tr></table></figure>

<h4 id="集群组件管理"><a href="#集群组件管理" class="headerlink" title="集群组件管理"></a>集群组件管理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动组件所有节点</span></span><br><span class="line">tiup cluster start tidb-test -R pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭组件所有节点</span></span><br><span class="line">tiup cluster stop tidb-test -R tidb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动某几个节点的组件</span></span><br><span class="line">tiup cluster start tidb-test -N &lt;ip&gt;:&lt;port&gt;,&lt;ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭某几个节点的组件</span></span><br><span class="line">tiup cluster stop tidb-test -N &lt;ip&gt;:&lt;port&gt;,&lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TiDB</category>
      </categories>
      <tags>
        <tag>TiDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim</title>
    <url>/2020/08/31/Vim/</url>
    <content><![CDATA[<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>参考文档：<a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p>
</blockquote>
<a id="more"></a>

<h2 id="常用按键"><a href="#常用按键" class="headerlink" title="常用按键"></a>常用按键</h2><h3 id="第一部分：一般模式"><a href="#第一部分：一般模式" class="headerlink" title="第一部分：一般模式"></a>第一部分：一般模式</h3><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h, j, k, l</td>
<td>光标向左，下，上，右移动</td>
</tr>
<tr>
<td>Ctrl + f / b</td>
<td>屏幕向下/上移动</td>
</tr>
<tr>
<td>Ctrl + d / u</td>
<td>屏幕向下/上移动半页</td>
</tr>
<tr>
<td>0</td>
<td>移动到一行的最前面</td>
</tr>
<tr>
<td>$</td>
<td>移动到一行的最后面字符</td>
</tr>
<tr>
<td>H / M / L</td>
<td>移动到屏幕最上方/中央/最下方那一行的第一个字符</td>
</tr>
<tr>
<td>G</td>
<td>移动到文件的最后一行</td>
</tr>
<tr>
<td>nG / ngg</td>
<td>移动到文件的第n行</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文件的第一行</td>
</tr>
<tr>
<td>n[Enter]</td>
<td>向下移动n行</td>
</tr>
</tbody></table>
<h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>/ <word></word></td>
<td>向下查找word字符串</td>
</tr>
<tr>
<td>? <word></word></td>
<td>向上查找word字符串</td>
</tr>
<tr>
<td>n</td>
<td>代表重复前一个查找动作</td>
</tr>
<tr>
<td>N</td>
<td>代表反向重复前一个查找动作</td>
</tr>
<tr>
<td>: s/<old>/<new></new></old></td>
<td>将第一个old替换为new</td>
</tr>
<tr>
<td>: s/<old>/<new>/g</new></old></td>
<td>将一行中所有的old替换为new</td>
</tr>
<tr>
<td>:n1, n2s/<word1>/<word2>/g</word2></word1></td>
<td>将行n1与n2之间的word1替换为word2</td>
</tr>
<tr>
<td>:%s/<old>/<new>/g</new></old></td>
<td>将文件所有的old替换为new</td>
</tr>
<tr>
<td>:%s/<old>/<new>/gc</new></old></td>
<td>替换前要求确认</td>
</tr>
</tbody></table>
<h4 id="删除复制粘贴"><a href="#删除复制粘贴" class="headerlink" title="删除复制粘贴"></a>删除复制粘贴</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>x/X</td>
<td>向后/前删除一个字符</td>
</tr>
<tr>
<td>nx</td>
<td>连续删除n个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除n行</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行数据</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标所在到该行最后一个字符</td>
</tr>
<tr>
<td>d0</td>
<td>删除光标所在到该行最前面一个字符</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在的一行</td>
</tr>
<tr>
<td>nyy</td>
<td>向下复制n行</td>
</tr>
<tr>
<td>y1G</td>
<td>复制光标所在到第一行数据</td>
</tr>
<tr>
<td>yG</td>
<td>复制光标所在到最后一行数据</td>
</tr>
<tr>
<td>y$</td>
<td>复制光标所在到该行最后一个字符</td>
</tr>
<tr>
<td>y0</td>
<td>复制光标所在到该行最前面一个字符</td>
</tr>
<tr>
<td>p/P</td>
<td>粘贴数据在光标下/上一行</td>
</tr>
<tr>
<td>J</td>
<td>将光标所在行与下一行数据结合成同一行</td>
</tr>
<tr>
<td>u</td>
<td>回撤前一操作</td>
</tr>
<tr>
<td>Ctrl + r</td>
<td>重做前一操作</td>
</tr>
<tr>
<td>.</td>
<td>重复前一个操作</td>
</tr>
</tbody></table>
<h3 id="第二部分：编辑模式"><a href="#第二部分：编辑模式" class="headerlink" title="第二部分：编辑模式"></a>第二部分：编辑模式</h3><h4 id="进入插入或替换的编辑模式"><a href="#进入插入或替换的编辑模式" class="headerlink" title="进入插入或替换的编辑模式"></a>进入插入或替换的编辑模式</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>i, I</td>
<td>进入插入模式： i从当前光标所在处插入，I在目前所在行的第一个非空格符处插入</td>
</tr>
<tr>
<td>a, A</td>
<td>进入插入模式： a从当前光标所在的下一个字符插入，A从光标所在行的最后一个字符后插入</td>
</tr>
<tr>
<td>o, O</td>
<td>进入插入模式： o从当前光标所在行的下一行插入新的一行；O正好相反，从上一行插入新行</td>
</tr>
<tr>
<td>r, R</td>
<td>进入替换模式： r只会替换光标所在的那一个字符一次；R会一直替换光标所在文字，直到Esc</td>
</tr>
</tbody></table>
<h4 id="块选择"><a href="#块选择" class="headerlink" title="块选择"></a>块选择</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>字符选择，将光标经过的地方反白选择</td>
</tr>
<tr>
<td>V</td>
<td>行选择，将光标经过的行反白选择</td>
</tr>
<tr>
<td>Ctrl + v</td>
<td>块选择，可以用长方形选择数据</td>
</tr>
<tr>
<td>y</td>
<td>将反白的地方复制</td>
</tr>
<tr>
<td>d</td>
<td>删除反白的地方</td>
</tr>
</tbody></table>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>：sp filename</td>
<td>打开新窗口，如果有加filename,新窗口打开新文件，否则打开相同文件</td>
</tr>
<tr>
<td>Ctrl + w + s/v</td>
<td>水平/垂直分割打开新窗口</td>
</tr>
<tr>
<td>Ctrl + w + h/j/k/l</td>
<td>光标移动到左/下/上/右窗口</td>
</tr>
<tr>
<td>Ctrl + w + q</td>
<td>退出窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
