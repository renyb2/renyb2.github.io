<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dijkstra</title>
    <url>/2020/08/27/Dijkstra/</url>
    <content><![CDATA[<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="问题1：最短路径"><a href="#问题1：最短路径" class="headerlink" title="问题1：最短路径"></a>问题1：最短路径</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="/2020/08/27/Dijkstra/Dijkstra-%E9%97%AE%E9%A2%981.png" alt="image-20200731221210621"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 代码构造上图</span><br><span class="line"></span><br><span class="line">graph &#x3D; &#123;</span><br><span class="line">    &quot;A&quot;: &#123;&quot;B&quot;: 5, &quot;C&quot;: 1&#125;,</span><br><span class="line">    &quot;B&quot;: &#123;&quot;A&quot;: 5, &quot;C&quot;: 2, &quot;D&quot;: 1&#125;,</span><br><span class="line">    &quot;C&quot;: &#123;&quot;A&quot;: 1, &quot;B&quot;: 2, &quot;D&quot;: 4, &quot;E&quot;: 8&#125;,</span><br><span class="line">    &quot;D&quot;: &#123;&quot;B&quot;: 1, &quot;C&quot;: 4, &quot;E&quot;: 3, &quot;F&quot;: 6&#125;,</span><br><span class="line">    &quot;E&quot;: &#123;&quot;C&quot;: 8, &quot;D&quot;: 3&#125;,</span><br><span class="line">    &quot;F&quot;: &#123;&quot;D&quot;: 6&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/27</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dijkstra.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化各点距离值，起始点距离为0，其余点距离为正无穷大</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_distance</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    distance = &#123;start: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> vertex != start:</span><br><span class="line">            distance[vertex] = math.inf</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录未走过的点，使用优先队列维护，权重为起始点至当前节点的最短距离</span></span><br><span class="line">    pqueue = []</span><br><span class="line">    heapq.heappush(pqueue, (<span class="number">0</span>, start))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录已经被走过的点，set()用于去重</span></span><br><span class="line">    seen = set()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录当前节点的父节点，即从哪来的</span></span><br><span class="line">    parent = &#123;start: <span class="literal">None</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录从起始点到各节点的最短距离</span></span><br><span class="line">    distance = init_distance(graph, start)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找起始点至所有点的最短路径</span></span><br><span class="line">    <span class="keyword">while</span> pqueue:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 从起始点开始走。队列非空时，拿出队列中权重最小的点</span></span><br><span class="line">        pair = heapq.heappop(pqueue)</span><br><span class="line">        dist = pair[<span class="number">0</span>]</span><br><span class="line">        vertex = pair[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从队列中拿出的点，即认为被看见</span></span><br><span class="line">        seen.add(vertex)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从图中查看当前父节点的所有相邻子节点</span></span><br><span class="line">        nodes = graph[vertex].keys()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="comment"># 如果父节点到子节点的距离小于记录中的距离，则把子节点加入队列中，并更新子节点的距离值和子节点的父节点信息</span></span><br><span class="line">                <span class="keyword">if</span> dist + graph[vertex][node] &lt; distance[node]:</span><br><span class="line">                    heapq.heappush(pqueue, (dist + graph[vertex][node], node))</span><br><span class="line">                    distance[node] = dist + graph[vertex][node]</span><br><span class="line">                    parent[node] = vertex</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回溯最短路径</span></span><br><span class="line">    path = [end]</span><br><span class="line">    <span class="keyword">while</span> parent[path[<span class="number">0</span>]]:</span><br><span class="line">        path.insert(<span class="number">0</span>, parent[path[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path, distance[end]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    graph = &#123;</span><br><span class="line">	    <span class="string">&quot;A&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>: <span class="number">5</span>, <span class="string">&quot;C&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;B&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">5</span>, <span class="string">&quot;C&quot;</span>: <span class="number">2</span>, <span class="string">&quot;D&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;C&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">1</span>, <span class="string">&quot;B&quot;</span>: <span class="number">2</span>, <span class="string">&quot;D&quot;</span>: <span class="number">4</span>, <span class="string">&quot;E&quot;</span>: <span class="number">8</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;D&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>: <span class="number">1</span>, <span class="string">&quot;C&quot;</span>: <span class="number">4</span>, <span class="string">&quot;E&quot;</span>: <span class="number">3</span>, <span class="string">&quot;F&quot;</span>: <span class="number">6</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;E&quot;</span>: &#123;<span class="string">&quot;C&quot;</span>: <span class="number">8</span>, <span class="string">&quot;D&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">	    <span class="string">&quot;F&quot;</span>: &#123;<span class="string">&quot;D&quot;</span>: <span class="number">6</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    path, distance = dijkstra(graph, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">    print(path)</span><br><span class="line">    print(distance)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Programming</title>
    <url>/2020/08/27/Dynamic-Programming/</url>
    <content><![CDATA[<h2 id="Dynamic-Programming（动态规划）"><a href="#Dynamic-Programming（动态规划）" class="headerlink" title="Dynamic Programming（动态规划）"></a>Dynamic Programming（动态规划）</h2><p>解决重复子问题</p>
<h3 id="问题1：0-1背包问题"><a href="#问题1：0-1背包问题" class="headerlink" title="问题1：0/1背包问题"></a>问题1：0/1背包问题</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N &#x3D; 5</span><br><span class="line">V &#x3D; 10</span><br><span class="line">w &#x3D; [2, 2, 6, 5, 4]</span><br><span class="line">v &#x3D; [6, 3, 5, 4, 6]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="问题2：斐波那契数列"><a href="#问题2：斐波那契数列" class="headerlink" title="问题2：斐波那契数列"></a>问题2：斐波那契数列</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>求第n个斐波那契数</p>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/31</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_opt</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> rec_opt(n<span class="number">-1</span>) + rec_opt(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp_opt</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        opt = np.zeros(n, dtype=int)</span><br><span class="line">        opt[<span class="number">0</span>], opt[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            opt[i] = opt[i<span class="number">-1</span>] + opt[i<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> opt[n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        print(<span class="string">&#x27;=====第%s个数=====&#x27;</span> % (i))</span><br><span class="line">        print(<span class="string">&#x27;递归结果： %s&#x27;</span> % (rec_opt(i)))</span><br><span class="line">        print(<span class="string">&#x27;非递归结果： %s&#x27;</span> % (dp_opt(i)))</span><br><span class="line">        print(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="问题3：求最大和"><a href="#问题3：求最大和" class="headerlink" title="问题3：求最大和"></a>问题3：求最大和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>Array内，隔一个选一个，求最大和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr &#x3D; [1, 4, 6, 1, 9, 2, 2, 3]</span><br></pre></td></tr></table></figure>



<h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/31</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_opt</span>(<span class="params">arr, i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> max(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        A = rec_opt(arr, i<span class="number">-1</span>)</span><br><span class="line">        B = rec_opt(arr, i<span class="number">-2</span>) + arr[i]</span><br><span class="line">        <span class="keyword">return</span> max(A, B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp_opt</span>(<span class="params">arr, i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> max(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        opt = np.zeros(i+<span class="number">1</span>, dtype=int)</span><br><span class="line">        opt[<span class="number">0</span>] = arr[<span class="number">0</span>]</span><br><span class="line">        opt[<span class="number">1</span>] = max(arr[<span class="number">0</span>], arr[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, i+<span class="number">1</span>):</span><br><span class="line">            A = opt[n<span class="number">-1</span>]</span><br><span class="line">            B = opt[n<span class="number">-2</span>] + arr[n]</span><br><span class="line">            opt[n] = max(A, B)</span><br><span class="line">        <span class="keyword">return</span> opt[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(rec_opt(arr, <span class="number">7</span>))</span><br><span class="line">    print(dp_opt(arr, <span class="number">7</span>))</span><br></pre></td></tr></table></figure>



<h3 id="问题4：是否可组成指定和"><a href="#问题4：是否可组成指定和" class="headerlink" title="问题4：是否可组成指定和"></a>问题4：是否可组成指定和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>数组Array（全是正整数），是否可以组成指定和S</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr &#x3D; [3, 34, 4, 12, 5, 2]</span><br><span class="line">S &#x3D; 9</span><br></pre></td></tr></table></figure>



<h4 id="python-2"><a href="#python-2" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/07/31</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : dp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rec_subset</span>(<span class="params">arr, i, S</span>):</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>] == S</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 剪枝</span></span><br><span class="line">    <span class="keyword">elif</span> arr[i] &gt; S:</span><br><span class="line">        <span class="keyword">return</span> rec_subset(arr, i<span class="number">-1</span>, S)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A = rec_subset(arr, i<span class="number">-1</span>, S-arr[i])</span><br><span class="line">        B = rec_subset(arr, i<span class="number">-1</span>, S)</span><br><span class="line">        <span class="keyword">return</span> A <span class="keyword">or</span> B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="comment">## 动态规划表：构造一个len(arr)行，S+1列的二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp_subset</span>(<span class="params">arr, S</span>):</span></span><br><span class="line">    subset = np.zeros((len(arr), S + <span class="number">1</span>), dtype=bool)</span><br><span class="line">    subset[:, <span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    subset[<span class="number">0</span>, :] = <span class="literal">False</span></span><br><span class="line">    subset[<span class="number">0</span>, arr[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">1</span>, S + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; s:</span><br><span class="line">                subset[i, s] = subset[i<span class="number">-1</span>, s]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = subset[i<span class="number">-1</span>, s-arr[i]]</span><br><span class="line">                B = subset[i<span class="number">-1</span>, s]</span><br><span class="line">                subset[i, s] = A <span class="keyword">or</span> B</span><br><span class="line">    <span class="keyword">return</span> subset[<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">3</span>, <span class="number">34</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">    print(dp_subset(arr, <span class="number">9</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">10</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">11</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">12</span>))</span><br><span class="line">    print(dp_subset(arr, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mosquitto</title>
    <url>/2020/08/31/Mosquitto/</url>
    <content><![CDATA[<h2 id="Mosquitto"><a href="#Mosquitto" class="headerlink" title="Mosquitto"></a>Mosquitto</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<a id="more"></a>

<p><img src="/2020/08/31/Mosquitto/1573118328615.png" alt="1573118328615"></p>
<h3 id="config-解析"><a href="#config-解析" class="headerlink" title="config 解析"></a>config 解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim mosquitto.conf</span><br><span class="line"></span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># General configuration</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 客户端心跳的间隔时间</span><br><span class="line">#retry_interval 20</span><br><span class="line"> </span><br><span class="line"># 系统状态的刷新时间</span><br><span class="line">#sys_interval 10</span><br><span class="line"> </span><br><span class="line"># 系统资源的回收时间，0表示尽快处理</span><br><span class="line">#store_clean_interval 10</span><br><span class="line"> </span><br><span class="line"># 服务进程的PID</span><br><span class="line">#pid_file &#x2F;var&#x2F;run&#x2F;mosquitto.pid</span><br><span class="line"> </span><br><span class="line"># 服务进程的系统用户</span><br><span class="line">#user mosquitto</span><br><span class="line"> </span><br><span class="line"># 客户端心跳消息的最大并发数</span><br><span class="line">#max_inflight_messages 10</span><br><span class="line"> </span><br><span class="line"># 客户端心跳消息缓存队列</span><br><span class="line">#max_queued_messages 100</span><br><span class="line"> </span><br><span class="line"># 用于设置客户端长连接的过期时间，默认永不过期</span><br><span class="line">#persistent_client_expiration</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Default listener</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 服务绑定的IP地址</span><br><span class="line">#bind_address</span><br><span class="line"> </span><br><span class="line"># 服务绑定的端口号</span><br><span class="line">#port 1883</span><br><span class="line"> </span><br><span class="line"># 允许的最大连接数，-1表示没有限制</span><br><span class="line">#max_connections -1</span><br><span class="line"> </span><br><span class="line"># cafile：CA证书文件</span><br><span class="line"># capath：CA证书目录</span><br><span class="line"># certfile：PEM证书文件</span><br><span class="line"># keyfile：PEM密钥文件</span><br><span class="line">#cafile</span><br><span class="line">#capath</span><br><span class="line">#certfile</span><br><span class="line">#keyfile</span><br><span class="line"> </span><br><span class="line"># 必须提供证书以保证数据安全性</span><br><span class="line">#require_certificate false</span><br><span class="line"> </span><br><span class="line"># 若require_certificate值为true，use_identity_as_username也必须为true</span><br><span class="line">#use_identity_as_username false</span><br><span class="line"> </span><br><span class="line"># 启用PSK（Pre-shared-key）支持</span><br><span class="line">#psk_hint</span><br><span class="line"> </span><br><span class="line"># SSL&#x2F;TSL加密算法，可以使用“openssl ciphers”命令获取</span><br><span class="line"># as the output of that command.</span><br><span class="line">#ciphers</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Persistence</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 消息自动保存的间隔时间</span><br><span class="line">#autosave_interval 1800</span><br><span class="line"> </span><br><span class="line"># 消息自动保存功能的开关</span><br><span class="line">#autosave_on_changes false</span><br><span class="line"> </span><br><span class="line"># 持久化功能的开关</span><br><span class="line">persistence true</span><br><span class="line"> </span><br><span class="line"># 持久化DB文件</span><br><span class="line">#persistence_file mosquitto.db</span><br><span class="line"> </span><br><span class="line"># 持久化DB文件目录</span><br><span class="line">#persistence_location &#x2F;var&#x2F;lib&#x2F;mosquitto&#x2F;</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Logging</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 4种日志模式：stdout、stderr、syslog、topic</span><br><span class="line"># none 则表示不记日志，此配置可以提升些许性能</span><br><span class="line">log_dest none</span><br><span class="line"> </span><br><span class="line"># 选择日志的级别（可设置多项）</span><br><span class="line">#log_type error</span><br><span class="line">#log_type warning</span><br><span class="line">#log_type notice</span><br><span class="line">#log_type information</span><br><span class="line"> </span><br><span class="line"># 是否记录客户端连接信息</span><br><span class="line">#connection_messages true</span><br><span class="line"> </span><br><span class="line"># 是否记录日志时间</span><br><span class="line">#log_timestamp true</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Security</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 客户端ID的前缀限制，可用于保证安全性</span><br><span class="line">#clientid_prefixes</span><br><span class="line"> </span><br><span class="line"># 允许匿名用户</span><br><span class="line">#allow_anonymous true</span><br><span class="line"> </span><br><span class="line"># 用户&#x2F;密码文件，默认格式：username:password</span><br><span class="line">#password_file</span><br><span class="line"> </span><br><span class="line"># PSK格式密码文件，默认格式：identity:key</span><br><span class="line">#psk_file</span><br><span class="line"> </span><br><span class="line"># pattern write sensor&#x2F;%u&#x2F;data</span><br><span class="line"># ACL权限配置，常用语法如下：</span><br><span class="line"># 用户限制：user &lt;username&gt;</span><br><span class="line"># 话题限制：topic [read|write] &lt;topic&gt;</span><br><span class="line"># 正则限制：pattern write sensor&#x2F;%u&#x2F;data</span><br><span class="line">#acl_file</span><br><span class="line"> </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Bridges</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"># 允许服务之间使用“桥接”模式（可用于分布式部署）</span><br><span class="line">#connection &lt;name&gt;</span><br><span class="line">#address &lt;host&gt;[:&lt;port&gt;]</span><br><span class="line">#topic &lt;topic&gt; [[[out | in | both] qos-level] local-prefix remote-prefix]</span><br><span class="line"> </span><br><span class="line"># 设置桥接的客户端ID</span><br><span class="line">#clientid</span><br><span class="line"> </span><br><span class="line"># 桥接断开时，是否清除远程服务器中的消息</span><br><span class="line">#cleansession false</span><br><span class="line"> </span><br><span class="line"># 是否发布桥接的状态信息</span><br><span class="line">#notifications true</span><br><span class="line"> </span><br><span class="line"># 设置桥接模式下，消息将会发布到的话题地址</span><br><span class="line"># $SYS&#x2F;broker&#x2F;connection&#x2F;&lt;clientid&gt;&#x2F;state</span><br><span class="line">#notification_topic</span><br><span class="line"> </span><br><span class="line"># 设置桥接的keepalive数值</span><br><span class="line">#keepalive_interval 60</span><br><span class="line"> </span><br><span class="line"># 桥接模式，目前有三种：automatic、lazy、once</span><br><span class="line">#start_type automatic</span><br><span class="line"> </span><br><span class="line"># 桥接模式automatic的超时时间</span><br><span class="line">#restart_timeout 30</span><br><span class="line"> </span><br><span class="line"># 桥接模式lazy的超时时间</span><br><span class="line">#idle_timeout 60</span><br><span class="line"> </span><br><span class="line"># 桥接客户端的用户名</span><br><span class="line">#username</span><br><span class="line"> </span><br><span class="line"># 桥接客户端的密码</span><br><span class="line">#password</span><br><span class="line"> </span><br><span class="line"># bridge_cafile：桥接客户端的CA证书文件</span><br><span class="line"># bridge_capath：桥接客户端的CA证书目录</span><br><span class="line"># bridge_certfile：桥接客户端的PEM证书文件</span><br><span class="line"># bridge_keyfile：桥接客户端的PEM密钥文件</span><br><span class="line">#bridge_cafile</span><br><span class="line">#bridge_capath</span><br><span class="line">#bridge_certfile</span><br><span class="line">#bridge_keyfile</span><br><span class="line"> </span><br><span class="line"># 自己的配置可以放到以下目录中</span><br><span class="line">#include_dir &#x2F;mqtt&#x2F;config&#x2F;conf.d</span><br></pre></td></tr></table></figure>

<h3 id="Qos-解析"><a href="#Qos-解析" class="headerlink" title="Qos 解析"></a>Qos 解析</h3><h4 id="Qos-0-–-gt-最多一次"><a href="#Qos-0-–-gt-最多一次" class="headerlink" title="Qos=0 –&gt; 最多一次"></a>Qos=0 –&gt; 最多一次</h4><blockquote>
<p>sequenceDiagram</p>
<p>ClientA-&gt;&gt;ServerBroker: 发送消息<br>ServerBroker-&gt;&gt;ClientB: 发送消息</p>
</blockquote>
<h4 id="Qos-1-–-gt-至少一次"><a href="#Qos-1-–-gt-至少一次" class="headerlink" title="Qos=1 –&gt; 至少一次"></a>Qos=1 –&gt; 至少一次</h4><blockquote>
<p>sequenceDiagram</p>
<p>ClientA-&gt;&gt;ServerBroker: 1.发送消息PUBLISH<br>ServerBroker-&gt;&gt;ServerBroker: 1.1存储消息<br>ServerBroker-&gt;&gt;ClientA: 1.2发送消息回应PUBACK<br>ServerBroker-&gt;&gt;ClientB: 2.发送消息<br>ClientB-&gt;&gt;ServerBroker: 2.1发送消息回应PUBACK<br>ServerBroker-&gt;&gt;ServerBroker: 2.2删除消息</p>
</blockquote>
<h4 id="Qos-2-–-gt-有且仅有一次"><a href="#Qos-2-–-gt-有且仅有一次" class="headerlink" title="Qos=2 –&gt; 有且仅有一次"></a>Qos=2 –&gt; 有且仅有一次</h4><blockquote>
<p>sequenceDiagram</p>
<p>ClientA-&gt;&gt;ServerBroker: 1.发送消息PUBLISH<br>ServerBroker-&gt;&gt;ServerBroker: 1.1存储消息<br>ServerBroker-&gt;&gt;ClientA: 1.2发送消息回应Rec<br>ClientA-&gt;&gt;ServerBroker: 2.发送消息Rel<br>ServerBroker-&gt;&gt;ServerBroker: 2.1删除消息<br>ServerBroker-&gt;&gt;ServerBroker: 2.2存储消息到发送列队<br>ServerBroker-&gt;&gt;ClientB: 2.3发送消息<br>ServerBroker-&gt;&gt;ClientA: 2.4发送消息回应Comp<br>ClientB-&gt;&gt;ServerBroker: 3.发送消息回应Rec<br>ServerBroker-&gt;&gt;ServerBroker: 3.1删除2.2中存储的消息（一次确认）<br>ServerBroker-&gt;&gt;ServerBroker: 3.2存储消息<br>ServerBroker-&gt;&gt;ClientB: 3.3发送消息Rel<br>ClientB-&gt;&gt;ServerBroker: 3.4发送消息回应Comp<br>ServerBroker-&gt;&gt;ServerBroker: 3.5删除消息(二次确认)</p>
</blockquote>
<p><img src="/2020/08/31/Mosquitto/1573118624880.png" alt="1573118624880"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验1：Mosquitto-内存数据落盘机制"><a href="#实验1：Mosquitto-内存数据落盘机制" class="headerlink" title="实验1：Mosquitto 内存数据落盘机制"></a>实验1：Mosquitto 内存数据落盘机制</h4><h5 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h5><p>​    Mosquitto 内存数据落盘持久化时，是否会产生重复数据</p>
<h5 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h5><p>​    Mosquitto 不会重复持久化已经持久化过的数据</p>
<h5 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h5><p>​    mosquitto version 1.4.15</p>
<h5 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h5><ol>
<li>发送者保持同样的发送速率，降低订阅者消费速度，触发mqtt的持久化机制</li>
<li>更改mqtt持久化的间隔（3s 和 30s），观测持久化的数据大小是否不同</li>
</ol>
<h5 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h5><blockquote>
<p>发送者：发送1w条消息，用时 31.16837883 s</p>
<p>订阅者：每分钟消化1条，1min内堆积9999条消息</p>
<p>Mosquitto：持久化间隔 3s，1min内涨幅 27842 Byte</p>
</blockquote>
<p><img src="/2020/08/31/Mosquitto/1573112430542.png" alt="1573112430542"></p>
<blockquote>
<p>发送者：发送1w条消息，</p>
<p>订阅者：每分钟消化1条，1min内堆积9999条消息</p>
<p>Mosquitto：持久化间隔 30s，1min内涨幅 27842 Byte</p>
</blockquote>
<p><img src="/2020/08/31/Mosquitto/1573113441213.png" alt="1573113441213"></p>
<h5 id="实验脚本"><a href="#实验脚本" class="headerlink" title="实验脚本"></a>实验脚本</h5><h6 id="send-py"><a href="#send-py" class="headerlink" title="send.py"></a>send.py</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">Send msg to mqtt (linux, python2)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">__author__ &#x3D; &#39;RYB&#39;</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import paho.mqtt.publish as publish</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ranstr(num):</span><br><span class="line">    salt &#x3D; &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, num))</span><br><span class="line">    return salt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def publish_msg(msg_num):</span><br><span class="line">    for i in range(msg_num):</span><br><span class="line">        msg &#x3D; &#123;</span><br><span class="line">            &quot;id&quot;: i,</span><br><span class="line">            &quot;Timestamp&quot;: int(time.time() * 1000),</span><br><span class="line">            &quot;str1&quot;: ranstr(50),</span><br><span class="line">            &quot;str2&quot;: ranstr(50)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publish.single(&quot;test&quot;, payload&#x3D;json.dumps(msg), qos&#x3D;2, hostname&#x3D;&quot;10.244.0.164&quot;, port&#x3D;1883)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">print(&quot;Running...&quot;)</span><br><span class="line">publish_msg(10000)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; End &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">print(&quot;Run Time: %s s&quot; % str(end - start))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="rec-py"><a href="#rec-py" class="headerlink" title="rec.py"></a>rec.py</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">Receive msg from mqtt (linux, python2)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">__author__ &#x3D; &#39;RYB&#39;</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import paho.mqtt.subscribe as subscribe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def on_message_sleep(client, userdata, msg):</span><br><span class="line">    print(msg.topic + &#39; --&gt; &#39; + msg.payload)</span><br><span class="line">    time.sleep(60)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subscribe.callback(on_message_sleep, &quot;test&quot;, qos&#x3D;2, hostname&#x3D;&quot;mosquitto&quot;, port&#x3D;1883)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3>]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort</title>
    <url>/2020/08/27/Sort/</url>
    <content><![CDATA[<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="算法1：冒泡排序"><a href="#算法1：冒泡排序" class="headerlink" title="算法1：冒泡排序"></a>算法1：冒泡排序</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><blockquote>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 [1]。</li>
</ol>
<p>参考资料：</p>
<ol>
<li>吕新平、刘宏铭．二级公共基础知识实战训练教程：西安交通大学出版社，2006.02：30页</li>
</ol>
</blockquote>
<a id="more"></a>

<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2020&#x2F;08&#x2F;01</span><br><span class="line"># @Author  : renyb</span><br><span class="line"># @File    : sort.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def bubble_sort(arr):</span><br><span class="line"></span><br><span class="line">    # 这个循环负责设置冒泡排序进行的次数</span><br><span class="line">    for i in range(len(arr) - 1):</span><br><span class="line"></span><br><span class="line">        # j为列表下标</span><br><span class="line">        for j in range(len(arr) - i - 1):  </span><br><span class="line">            if arr[j] &gt; arr[j + 1]:</span><br><span class="line">                arr[j], arr[j + 1] &#x3D; arr[j + 1], arr[j]</span><br><span class="line">    return arr</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [2,3,5,7,1,4,6,15,5,2,7,9,10,15,9,17,12]</span><br><span class="line">    print(bubble_sort(array))</span><br></pre></td></tr></table></figure>



<h3 id="算法2：选择排序"><a href="#算法2：选择排序" class="headerlink" title="算法2：选择排序"></a>算法2：选择排序</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕 [1]。</p>
<p>参考文档：</p>
<ol>
<li><p>Ajay Kumar．Data Structure for C Programming：Firewall Media，2004：268-270</p>
</li>
<li><p>Hosam M.Mahmoud．Sorting: A Distribution Theory：John Wiley&amp;Sons, Inc，2000：139-142</p>
</li>
</ol>
</blockquote>
<h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从数组的前n个中寻找最大值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_index</span>(<span class="params">arr, n</span>):</span></span><br><span class="line">    max_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt; arr[max_index]:</span><br><span class="line">            max_index = i</span><br><span class="line">    <span class="keyword">return</span> max_index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    i = len(arr)</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        max_index = find_max_index(arr, i)</span><br><span class="line">        arr[i<span class="number">-1</span>], arr[max_index] = arr[max_index], arr[i<span class="number">-1</span>]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(select_sort(arr))</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="算法3：插入排序"><a href="#算法3：插入排序" class="headerlink" title="算法3：插入排序"></a>算法3：插入排序</h3><h4 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌 [1]。</p>
<p>参考文档：</p>
<ol>
<li>（美）科尔曼等著；殷建平等译．算法导论．北京：机械工业出版社，2013：17-29</li>
</ol>
</blockquote>
<h4 id="python-2"><a href="#python-2" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将索引为i的数插入数组前半部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">arr, i</span>):</span></span><br><span class="line">    temp = arr[i]</span><br><span class="line">    <span class="keyword">while</span> arr[i<span class="number">-1</span>] &gt; temp:</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 防越界</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    arr[i] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        insert(arr, i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(insert_sort(arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="算法4：快速排序"><a href="#算法4：快速排序" class="headerlink" title="算法4：快速排序"></a>算法4：快速排序</h3><h4 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动 [1]。</p>
<p><img src="/2020/08/27/Sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p>
<p>一趟快速排序的算法是：</p>
<p>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</p>
<p>2）以第一个数组元素作为关键数据，赋值给<strong>key</strong>，即<strong>key</strong>=A[0]；</p>
<p>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于<strong>key</strong>的值A[j]，将A[j]和A[i]的值交换；</p>
<p>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于<strong>key</strong>的A[i]，将A[i]和A[j]的值交换；</p>
<p>5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于<strong>key</strong>,4中A[i]不大于<strong>key</strong>的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<p>参考资料：</p>
<ol>
<li>陈雄达，关晓飞，殷俊锋，张华隆编．数学实验：同济大学出版社，2016.08：第135页</li>
</ol>
</blockquote>
<h4 id="python-3"><a href="#python-3" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/01</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : sort.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归 + 分而治之</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归入口及出口</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &gt;= <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选取基准值，也可以选取最后一个元素</span></span><br><span class="line">        mid = arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义基准值左右两侧的列表</span></span><br><span class="line">        left, right = [], []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从原始数组中移除基准值</span></span><br><span class="line">        arr.remove(mid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= mid:</span><br><span class="line">                right.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left.append(num)</span><br><span class="line">        <span class="keyword">return</span> quick_sort(left) + [mid] + quick_sort(right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(quick_sort(array))</span><br></pre></td></tr></table></figure>



<h3 id="算法5：堆排序"><a href="#算法5：堆排序" class="headerlink" title="算法5：堆排序"></a>算法5：堆排序</h3><h4 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作 [1]：</p>
<ul>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p><img src="/2020/08/27/Sort/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p>
<p>参考资料：</p>
<ol>
<li>Floyd, Robert W. (1964), “Algorithm 245 - Treesort 3”, Communications of the ACM, 7 (12): 701, doi:10.1145/355588.365103</li>
</ol>
</blockquote>
<h4 id="python-4"><a href="#python-4" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点间的索引关系：</span></span><br><span class="line"><span class="comment"># 节点：i</span></span><br><span class="line"><span class="comment"># 父节点：(i - 1) / 2</span></span><br><span class="line"><span class="comment"># 左子节点：2i + 1</span></span><br><span class="line"><span class="comment"># 右子节点：2i + 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">tree, n, i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    c1 = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    c2 = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    max = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c1 &lt; n <span class="keyword">and</span> tree[c1] &gt; tree[max]:</span><br><span class="line">        max = c1</span><br><span class="line">    <span class="keyword">if</span> c2 &lt; n <span class="keyword">and</span> tree[c2] &gt; tree[max]:</span><br><span class="line">        max = c2</span><br><span class="line">    <span class="keyword">if</span> max != i:</span><br><span class="line">        tree[max], tree[i] = tree[i], tree[max]</span><br><span class="line">        heapify(tree, n, max)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span>(<span class="params">tree, n</span>):</span></span><br><span class="line">    last_node = n - <span class="number">1</span></span><br><span class="line">    parent = (last_node - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> parent &gt;= <span class="number">0</span>:</span><br><span class="line">        heapify(tree, n, parent)</span><br><span class="line">        parent -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">tree</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建堆</span></span><br><span class="line">    n = len(tree)</span><br><span class="line">    build_heap(tree, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 第一个节点与最后一个节点交换</span></span><br><span class="line">        tree[<span class="number">0</span>], tree[n<span class="number">-1</span>] = tree[n<span class="number">-1</span>], tree[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 剩下的节点重新构建堆</span></span><br><span class="line">        build_heap(tree, n<span class="number">-1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    tree = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    heap_sort(tree)</span><br><span class="line">    print(tree)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="算法6：归并排序"><a href="#算法6：归并排序" class="headerlink" title="算法6：归并排序"></a>算法6：归并排序</h3><h4 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a>思想</h4><blockquote>
<p>归并操作，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。</p>
<p>如　设有数列{6，202，100，301，38，8，1}</p>
<p>初始状态：6,202,100,301,38,8,1</p>
<p>第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；</p>
<p>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；</p>
<p>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；</p>
<p>总的比较次数为：3+4+4=11；</p>
<p>逆序数为14；</p>
<p><img src="/2020/08/27/Sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p>
<p>归并操作的工作原理如下：</p>
<p>第一步：申请空间，使其大小为两个已经<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F">排序</a>序列之和，该空间用来存放合并后的序列</p>
<p>第二步：设定两个<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，最初位置分别为两个已经排序序列的起始位置</p>
<p>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
<p>重复步骤3直到某一指针超出序列尾</p>
<p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</blockquote>
<h4 id="python-5"><a href="#python-5" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2020/08/08</span></span><br><span class="line"><span class="comment"># @Author  : renyb</span></span><br><span class="line"><span class="comment"># @File    : demo.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将左右两个数组合并</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定两个指针，分别指向左右两个数组的开始位置</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并后的数组</span></span><br><span class="line">    record = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左右两个数组均未被遍历完</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            record.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            record.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果左右两个数组有一个遍历完，将另一个剩余元素添加至record尾部</span></span><br><span class="line">    record += left[i:]</span><br><span class="line">    record += right[j:]</span><br><span class="line">    <span class="keyword">return</span> record</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归 + 分治</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 数组从中间切分</span></span><br><span class="line">    i = len(arr) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(arr[:i])</span><br><span class="line">    right = merge_sort(arr[i:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>]</span><br><span class="line">    print(merge_sort(arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim</title>
    <url>/2020/08/31/Vim/</url>
    <content><![CDATA[<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>参考文档：<a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p>
</blockquote>
<a id="more"></a>

<h2 id="常用按键"><a href="#常用按键" class="headerlink" title="常用按键"></a>常用按键</h2><h3 id="第一部分：一般模式"><a href="#第一部分：一般模式" class="headerlink" title="第一部分：一般模式"></a>第一部分：一般模式</h3><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h, j, k, l</td>
<td>光标向左，下，上，右移动</td>
</tr>
<tr>
<td>Ctrl + f / b</td>
<td>屏幕向下/上移动</td>
</tr>
<tr>
<td>Ctrl + d / u</td>
<td>屏幕向下/上移动半页</td>
</tr>
<tr>
<td>0</td>
<td>移动到一行的最前面</td>
</tr>
<tr>
<td>$</td>
<td>移动到一行的最后面字符</td>
</tr>
<tr>
<td>H / M / L</td>
<td>移动到屏幕最上方/中央/最下方那一行的第一个字符</td>
</tr>
<tr>
<td>G</td>
<td>移动到文件的最后一行</td>
</tr>
<tr>
<td>nG / ngg</td>
<td>移动到文件的第n行</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文件的第一行</td>
</tr>
<tr>
<td>n[Enter]</td>
<td>向下移动n行</td>
</tr>
</tbody></table>
<h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>/ <word></word></td>
<td>向下查找word字符串</td>
</tr>
<tr>
<td>? <word></word></td>
<td>向上查找word字符串</td>
</tr>
<tr>
<td>n</td>
<td>代表重复前一个查找动作</td>
</tr>
<tr>
<td>N</td>
<td>代表反向重复前一个查找动作</td>
</tr>
<tr>
<td>: s/<old>/<new></new></old></td>
<td>将第一个old替换为new</td>
</tr>
<tr>
<td>: s/<old>/<new>/g</new></old></td>
<td>将一行中所有的old替换为new</td>
</tr>
<tr>
<td>:n1, n2s/<word1>/<word2>/g</word2></word1></td>
<td>将行n1与n2之间的word1替换为word2</td>
</tr>
<tr>
<td>:%s/<old>/<new>/g</new></old></td>
<td>将文件所有的old替换为new</td>
</tr>
<tr>
<td>:%s/<old>/<new>/gc</new></old></td>
<td>替换前要求确认</td>
</tr>
</tbody></table>
<h4 id="删除复制粘贴"><a href="#删除复制粘贴" class="headerlink" title="删除复制粘贴"></a>删除复制粘贴</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>x/X</td>
<td>向后/前删除一个字符</td>
</tr>
<tr>
<td>nx</td>
<td>连续删除n个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除n行</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行数据</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标所在到该行最后一个字符</td>
</tr>
<tr>
<td>d0</td>
<td>删除光标所在到该行最前面一个字符</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在的一行</td>
</tr>
<tr>
<td>nyy</td>
<td>向下复制n行</td>
</tr>
<tr>
<td>y1G</td>
<td>复制光标所在到第一行数据</td>
</tr>
<tr>
<td>yG</td>
<td>复制光标所在到最后一行数据</td>
</tr>
<tr>
<td>y$</td>
<td>复制光标所在到该行最后一个字符</td>
</tr>
<tr>
<td>y0</td>
<td>复制光标所在到该行最前面一个字符</td>
</tr>
<tr>
<td>p/P</td>
<td>粘贴数据在光标下/上一行</td>
</tr>
<tr>
<td>J</td>
<td>将光标所在行与下一行数据结合成同一行</td>
</tr>
<tr>
<td>u</td>
<td>回撤前一操作</td>
</tr>
<tr>
<td>Ctrl + r</td>
<td>重做前一操作</td>
</tr>
<tr>
<td>.</td>
<td>重复前一个操作</td>
</tr>
</tbody></table>
<h3 id="第二部分：编辑模式"><a href="#第二部分：编辑模式" class="headerlink" title="第二部分：编辑模式"></a>第二部分：编辑模式</h3><h4 id="进入插入或替换的编辑模式"><a href="#进入插入或替换的编辑模式" class="headerlink" title="进入插入或替换的编辑模式"></a>进入插入或替换的编辑模式</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>i, I</td>
<td>进入插入模式： i从当前光标所在处插入，I在目前所在行的第一个非空格符处插入</td>
</tr>
<tr>
<td>a, A</td>
<td>进入插入模式： a从当前光标所在的下一个字符插入，A从光标所在行的最后一个字符后插入</td>
</tr>
<tr>
<td>o, O</td>
<td>进入插入模式： o从当前光标所在行的下一行插入新的一行；O正好相反，从上一行插入新行</td>
</tr>
<tr>
<td>r, R</td>
<td>进入替换模式： r只会替换光标所在的那一个字符一次；R会一直替换光标所在文字，直到Esc</td>
</tr>
</tbody></table>
<h4 id="块选择"><a href="#块选择" class="headerlink" title="块选择"></a>块选择</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>字符选择，将光标经过的地方反白选择</td>
</tr>
<tr>
<td>V</td>
<td>行选择，将光标经过的行反白选择</td>
</tr>
<tr>
<td>Ctrl + v</td>
<td>块选择，可以用长方形选择数据</td>
</tr>
<tr>
<td>y</td>
<td>将反白的地方复制</td>
</tr>
<tr>
<td>d</td>
<td>删除反白的地方</td>
</tr>
</tbody></table>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>：sp filename</td>
<td>打开新窗口，如果有加filename,新窗口打开新文件，否则打开相同文件</td>
</tr>
<tr>
<td>Ctrl + w + s/v</td>
<td>水平/垂直分割打开新窗口</td>
</tr>
<tr>
<td>Ctrl + w + h/j/k/l</td>
<td>光标移动到左/下/上/右窗口</td>
</tr>
<tr>
<td>Ctrl + w + q</td>
<td>退出窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
