<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OpenStack研发：Trove Cluster Controller | 任翌博的个人博客</title><meta name="description" content="概述对程序员来说，最好的文档就是源码。Trove 官方对于Clueter Controller能力的描述文档不多，给的参考例子只涉及到MongoDB集群，参考Set up database clustering。为了深入了解Trove的集群能力，本文档对Trove Cluster Controller的能力进行深入剖析，从API入手，解析如何构建整个后端数据库集群生命周期管理架构。摸清Trove现"><meta name="keywords" content="OpenStack,Trove"><meta name="author" content="任翌博"><meta name="copyright" content="任翌博"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://renyb2.github.io/2022/01/25/OpenStack%E7%A0%94%E5%8F%91%EF%BC%9ATrove-Cluster-Controller/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="OpenStack研发：Trove Cluster Controller"><meta property="og:url" content="https://renyb2.github.io/2022/01/25/OpenStack%E7%A0%94%E5%8F%91%EF%BC%9ATrove-Cluster-Controller/"><meta property="og:site_name" content="任翌博的个人博客"><meta property="og:description" content="概述对程序员来说，最好的文档就是源码。Trove 官方对于Clueter Controller能力的描述文档不多，给的参考例子只涉及到MongoDB集群，参考Set up database clustering。为了深入了解Trove的集群能力，本文档对Trove Cluster Controller的能力进行深入剖析，从API入手，解析如何构建整个后端数据库集群生命周期管理架构。摸清Trove现"><meta property="og:image" content="https://www.leixue.com/uploads/2019/07/OpenStack.png"><meta property="article:published_time" content="2022-01-25T09:45:32.000Z"><meta property="article:modified_time" content="2022-05-10T07:04:52.952Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"limitCount":50,"languages":{"author":"作者: 任翌博","link":"链接: ","source":"来源: 任翌博的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-05-10 15:04:52'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="任翌博的个人博客" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">67</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">57</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC"><span class="toc-number">2.</span> <span class="toc-text">版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%94%9F%E8%83%BD%E5%8A%9B"><span class="toc-number">3.</span> <span class="toc-text">源生能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Clueter-%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.</span> <span class="toc-text">Clueter 相关接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clueter-%E6%94%AF%E6%8C%81%E7%9A%84%E9%9B%86%E7%BE%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Clueter 支持的集群类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B5%B0%E8%AF%BB"><span class="toc-number">4.</span> <span class="toc-text">代码走读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">5.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://www.leixue.com/uploads/2019/07/OpenStack.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">任翌博的个人博客</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">OpenStack研发：Trove Cluster Controller</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-25T09:45:32.000Z" title="发表于 2022-01-25 17:45:32">2022-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-10T07:04:52.952Z" title="更新于 2022-05-10 15:04:52">2022-05-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OpenStack/">OpenStack</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对程序员来说，最好的文档就是源码。Trove 官方对于<strong>Clueter Controller</strong>能力的描述文档不多，给的参考例子只涉及到MongoDB集群，参考<a target="_blank" rel="noopener" href="https://docs.openstack.org/trove/wallaby/user/set-up-clustering.html">Set up database clustering</a>。为了深入了解Trove的集群能力，本文档对<code>Trove Cluster Controller</code>的能力进行深入剖析，从API入手，解析如何构建整个后端数据库集群生命周期管理架构。摸清Trove现有能力的同时，梳理代码设计思路，为后续研发做准备。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>OpenStack Train版本（16 October, 2019）</li>
<li>Trove 12.1.0</li>
</ul>
<p><strong>备注：</strong></p>
<p>在深入剖析Trove源码后，发现Trove在14.0.0后，调整了虚机内数据库服务的部署方式，从原先的直接RPM部署调整为Docker部署，优点就是横向扩展很容易，缺点是为了打通Trove虚机与Docker仓库的网络，导致Trove服务网络结构会比较复杂。<strong>Trove更新为docker后，留了一个深坑，就是原先已支持的数据库，现在很多都不支持了，Guest Agent正在重构。目前最新版本支持情况：MySQL 5.7.X, MariaDB 10.4.X. PostgreSQL 12.4 is partially supported</strong>。目前已经两个大版本过去了，依然没有新的数据库类型支持，考虑到研发代价，决定使用弃用Docker形式的新版本，使用稳定的老版本。</p>
<p><img src="/2022/01/25/OpenStack%E7%A0%94%E5%8F%91%EF%BC%9ATrove-Cluster-Controller/trove-releasenote-14.0.0.png" alt="trove-releasenote-14.0.0"></p>
<p><img src="/2022/01/25/OpenStack%E7%A0%94%E5%8F%91%EF%BC%9ATrove-Cluster-Controller/trove-administrator-guide-16.0.0.png" alt="trove-administrator-guide-16.0.0"></p>
<h2 id="源生能力"><a href="#源生能力" class="headerlink" title="源生能力"></a>源生能力</h2><h3 id="Clueter-相关接口"><a href="#Clueter-相关接口" class="headerlink" title="Clueter 相关接口"></a>Clueter 相关接口</h3><table>
<thead>
<tr>
<th>接口</th>
<th>接口路由</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>index cluster</td>
<td><code>/&#123;tenant_id&#125;/clusters</code></td>
<td>GET</td>
</tr>
<tr>
<td>show cluster</td>
<td><code>/&#123;tenant_id&#125;/clusters/&#123;id&#125;</code></td>
<td>GET</td>
</tr>
<tr>
<td>create cluster</td>
<td><code>/&#123;tenant_id&#125;/clusters</code></td>
<td>POST</td>
</tr>
<tr>
<td>cluster action</td>
<td><code>/&#123;tenant_id&#125;/clusters/&#123;id&#125;</code></td>
<td>POST</td>
</tr>
<tr>
<td>show instance in cluster</td>
<td><code>/&#123;tenant_id&#125;/clusters/&#123;cluster_id&#125;/instances/</code></td>
<td>GET</td>
</tr>
<tr>
<td>delete cluster</td>
<td><code>/&#123;tenant_id&#125;/clusters/&#123;id&#125;</code></td>
<td>DELETE</td>
</tr>
</tbody></table>
<h3 id="Clueter-支持的集群类型"><a href="#Clueter-支持的集群类型" class="headerlink" title="Clueter 支持的集群类型"></a>Clueter 支持的集群类型</h3><table>
<thead>
<tr>
<th>数据库</th>
<th>集群类型</th>
<th>入口函数（strategy）</th>
</tr>
</thead>
<tbody><tr>
<td><em>Percona XtraDB</em></td>
<td>Galera</td>
<td><code>trove.common.strategies.cluster.experimental.galera_common</code></td>
</tr>
<tr>
<td><em>MariaDB</em></td>
<td>Galera</td>
<td><code>trove.common.strategies.cluster.experimental.galera_common</code></td>
</tr>
<tr>
<td><em>Redis</em></td>
<td>Redis Cluster</td>
<td><code>trove.common.strategies.cluster.experimental.redis</code></td>
</tr>
<tr>
<td><em>MongoDB</em></td>
<td>MongoDB Cluster</td>
<td><code>trove.common.strategies.cluster.experimental.mongodb</code></td>
</tr>
<tr>
<td><em>Cassandra</em></td>
<td>Cassandra Cluster</td>
<td><code>trove.common.strategies.cluster.experimental.cassandra</code></td>
</tr>
<tr>
<td><em>Vertica</em></td>
<td>Vertica Cluster</td>
<td><code>trove.common.strategies.cluster.experimental.vertica</code></td>
</tr>
</tbody></table>
<h2 id="代码走读"><a href="#代码走读" class="headerlink" title="代码走读"></a>代码走读</h2><p>OpenStack源码分析，需要从组件包管理<code>setup.cfg</code>中的<code>entry_points</code>入手，根据<code>entry_points</code>中<code>trove-api</code>的配置，确定入口为<code>trove.cmd.api:main</code>。<code>setup.cfg</code>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[entry_points]</span><br><span class="line">console_scripts &#x3D; </span><br><span class="line">	trove-api &#x3D; trove.cmd.api:main</span><br><span class="line">	trove-taskmanager &#x3D; trove.cmd.taskmanager:main</span><br><span class="line">	trove-mgmt-taskmanager &#x3D; trove.cmd.taskmanager:mgmt_main</span><br><span class="line">	trove-conductor &#x3D; trove.cmd.conductor:main</span><br><span class="line">	trove-manage &#x3D; trove.cmd.manage:main</span><br><span class="line">	trove-guestagent &#x3D; trove.cmd.guest:main</span><br><span class="line">	trove-fake-mode &#x3D; trove.cmd.fakemode:main</span><br><span class="line">	trove-status &#x3D; trove.cmd.status:main</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>trove-api调用wsgi模块，启动api服务。源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.cmd.api</span></span><br><span class="line"><span class="keyword">from</span> oslo_concurrency <span class="keyword">import</span> processutils</span><br><span class="line"><span class="keyword">from</span> trove.cmd.common <span class="keyword">import</span> with_initialize</span><br><span class="line"><span class="keyword">from</span> trove.common <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@with_initialize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">CONF</span>):</span></span><br><span class="line">    <span class="keyword">from</span> trove.common <span class="keyword">import</span> cfg</span><br><span class="line">    <span class="keyword">from</span> trove.common <span class="keyword">import</span> notification</span><br><span class="line">    <span class="keyword">from</span> trove.common <span class="keyword">import</span> wsgi</span><br><span class="line">    <span class="keyword">from</span> trove.instance <span class="keyword">import</span> models <span class="keyword">as</span> inst_models</span><br><span class="line"></span><br><span class="line">    notification.DBaaSAPINotification.register_notify_callback(</span><br><span class="line">        inst_models.persist_instance_fault)</span><br><span class="line">    cfg.set_api_config_defaults()</span><br><span class="line">    profile.setup_profiler(<span class="string">&#x27;api&#x27;</span>, CONF.host)</span><br><span class="line">    conf_file = CONF.find_file(CONF.api_paste_config)</span><br><span class="line">    workers = CONF.trove_api_workers <span class="keyword">or</span> processutils.get_worker_count()</span><br><span class="line">    launcher = wsgi.launch(<span class="string">&#x27;trove&#x27;</span>, CONF.bind_port, conf_file,</span><br><span class="line">                           host=CONF.bind_host, workers=workers)</span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure>

<p>确定trove api接口能力，需要先从wsgi模块关于Router的定义，其中<code>wsgi.Router</code>主要负责对请求进行匹配，未匹配到返回<code>404 HTTPNotFound</code>。<code>base_wsgi.Router</code>为<code>wsgi.Router</code>的父类，定义了Router的使用方式。相关源码见下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.common.wsgi</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>(<span class="params">base_wsgi.Router</span>):</span></span><br><span class="line">    <span class="comment"># Original router did not allow for serialization of the 404 error.</span></span><br><span class="line">    <span class="comment"># To fix this the _dispatch was modified to use Fault() objects.</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @webob.dec.wsgify</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dispatch</span>(<span class="params">req</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Called by self._router after matching the incoming request to a route</span></span><br><span class="line"><span class="string">        and putting the information into req.environ.  Either returns 404</span></span><br><span class="line"><span class="string">        or the routed WSGI app&#x27;s response.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        match = req.environ[<span class="string">&#x27;wsgiorg.routing_args&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:</span><br><span class="line">            <span class="keyword">return</span> Fault(webob.exc.HTTPNotFound())</span><br><span class="line">        app = match[<span class="string">&#x27;controller&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># trove.common.base_wsgi</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    WSGI middleware that maps incoming requests to WSGI apps.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mapper</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create a router for the given routes.Mapper.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Each route in `mapper` must specify a &#x27;controller&#x27;, which is a</span></span><br><span class="line"><span class="string">        WSGI app to call.  You&#x27;ll probably want to specify an &#x27;action&#x27; as</span></span><br><span class="line"><span class="string">        well and have your controller be a wsgi.Controller, who will route</span></span><br><span class="line"><span class="string">        the request to the action method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">          mapper = routes.Mapper()</span></span><br><span class="line"><span class="string">          sc = ServerController()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Explicit mapping of one route to a controller+action</span></span><br><span class="line"><span class="string">          mapper.connect(None, &quot;/svrlist&quot;, controller=sc, action=&quot;list&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Actions are all implicitly defined</span></span><br><span class="line"><span class="string">          mapper.resource(&quot;server&quot;, &quot;servers&quot;, controller=sc)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Pointing to an arbitrary WSGI app.  You can specify the</span></span><br><span class="line"><span class="string">          # &#123;path_info:.*&#125; parameter so the target app can be handed just that</span></span><br><span class="line"><span class="string">          # section of the URL.</span></span><br><span class="line"><span class="string">          mapper.connect(None, &quot;/v1.0/&#123;path_info:.*&#125;&quot;, controller=BlogApp())</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.map = mapper</span><br><span class="line">        self._router = routes.middleware.RoutesMiddleware(self._dispatch,</span><br><span class="line">                                                          self.map)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @webob.dec.wsgify</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, req</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Route the incoming request to a controller based on self.map.</span></span><br><span class="line"><span class="string">        If no match, return a 404.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._router</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @webob.dec.wsgify</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dispatch</span>(<span class="params">req</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Called by self._router after matching the incoming request to a route</span></span><br><span class="line"><span class="string">        and putting the information into req.environ.  Either returns 404</span></span><br><span class="line"><span class="string">        or the routed WSGI app&#x27;s response.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        match = req.environ[<span class="string">&#x27;wsgiorg.routing_args&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:</span><br><span class="line">            <span class="keyword">return</span> webob.exc.HTTPNotFound()</span><br><span class="line">        app = match[<span class="string">&#x27;controller&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>trove api的详细router定义是在<code>trove.common.api:API</code>中，定义了trove api所有接口路由。根据Trove API Rrouter定义的接口，cluster支持增删改查能力，Cluster Controller的路由代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.common.api</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cluster_router</span>(<span class="params">self, mapper</span>):</span></span><br><span class="line">        cluster_resource = ClusterController().create_resource()</span><br><span class="line">        mapper.connect(<span class="string">&quot;/&#123;tenant_id&#125;/clusters&quot;</span>,</span><br><span class="line">                       controller=cluster_resource,</span><br><span class="line">                       action=<span class="string">&quot;index&quot;</span>,</span><br><span class="line">                       conditions=&#123;<span class="string">&#x27;method&#x27;</span>: [<span class="string">&#x27;GET&#x27;</span>]&#125;)</span><br><span class="line">        mapper.connect(<span class="string">&quot;/&#123;tenant_id&#125;/clusters/&#123;id&#125;&quot;</span>,</span><br><span class="line">                       controller=cluster_resource,</span><br><span class="line">                       action=<span class="string">&quot;show&quot;</span>,</span><br><span class="line">                       conditions=&#123;<span class="string">&#x27;method&#x27;</span>: [<span class="string">&#x27;GET&#x27;</span>]&#125;)</span><br><span class="line">        mapper.connect(<span class="string">&quot;/&#123;tenant_id&#125;/clusters&quot;</span>,</span><br><span class="line">                       controller=cluster_resource,</span><br><span class="line">                       action=<span class="string">&quot;create&quot;</span>,</span><br><span class="line">                       conditions=&#123;<span class="string">&#x27;method&#x27;</span>: [<span class="string">&#x27;POST&#x27;</span>]&#125;)</span><br><span class="line">        mapper.connect(<span class="string">&quot;/&#123;tenant_id&#125;/clusters/&#123;id&#125;&quot;</span>,</span><br><span class="line">                       controller=cluster_resource,</span><br><span class="line">                       action=<span class="string">&quot;action&quot;</span>,</span><br><span class="line">                       conditions=&#123;<span class="string">&#x27;method&#x27;</span>: [<span class="string">&#x27;POST&#x27;</span>]&#125;)</span><br><span class="line">        mapper.connect(<span class="string">&quot;/&#123;tenant_id&#125;/clusters/&#123;cluster_id&#125;/instances/&quot;</span></span><br><span class="line">                       <span class="string">&quot;&#123;instance_id&#125;&quot;</span>,</span><br><span class="line">                       controller=cluster_resource,</span><br><span class="line">                       action=<span class="string">&quot;show_instance&quot;</span>,</span><br><span class="line">                       conditions=&#123;<span class="string">&#x27;method&#x27;</span>: [<span class="string">&#x27;GET&#x27;</span>]&#125;)</span><br><span class="line">        mapper.connect(<span class="string">&quot;/&#123;tenant_id&#125;/clusters/&#123;id&#125;&quot;</span>,</span><br><span class="line">                       controller=cluster_resource,</span><br><span class="line">                       action=<span class="string">&quot;delete&quot;</span>,</span><br><span class="line">                       conditions=&#123;<span class="string">&#x27;method&#x27;</span>: [<span class="string">&#x27;DELETE&#x27;</span>]&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们从创建流程入手，进行更深一步的分析。路由中定义的后端响应类为<code>trove.cluster.service:ClusterController</code>,每个路由对应一个具体的方法，关于创建的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.cluster.service</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">from</span> trove.cluster <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClusterController</span>(<span class="params">wsgi.Controller</span>):</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, req, body, tenant_id</span>):</span></span><br><span class="line">        LOG.debug((<span class="string">&quot;Creating a Cluster for Tenant &#x27;%(tenant_id)s&#x27;\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;req : &#x27;%(req)s&#x27;\n\nbody : &#x27;%(body)s&#x27;\n\n&quot;</span>),</span><br><span class="line">                  &#123;<span class="string">&quot;tenant_id&quot;</span>: tenant_id, <span class="string">&quot;req&quot;</span>: req, <span class="string">&quot;body&quot;</span>: body&#125;)</span><br><span class="line"></span><br><span class="line">        context = req.environ[wsgi.CONTEXT_KEY]</span><br><span class="line">        policy.authorize_on_tenant(context, <span class="string">&#x27;cluster:create&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        name = body[<span class="string">&#x27;cluster&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        datastore_args = body[<span class="string">&#x27;cluster&#x27;</span>].get(<span class="string">&#x27;datastore&#x27;</span>, &#123;&#125;)</span><br><span class="line">        datastore, datastore_version = (</span><br><span class="line">            datastore_models.get_datastore_version(**datastore_args))</span><br><span class="line"></span><br><span class="line">        extended_properties = body[<span class="string">&#x27;cluster&#x27;</span>].get(<span class="string">&#x27;extended_properties&#x27;</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            clusters_enabled = (CONF.get(datastore_version.manager)</span><br><span class="line">                                .get(<span class="string">&#x27;cluster_support&#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span> NoSuchOptError:</span><br><span class="line">            clusters_enabled = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> clusters_enabled:</span><br><span class="line">            <span class="keyword">raise</span> exception.ClusterDatastoreNotSupported(</span><br><span class="line">                datastore=datastore.name,</span><br><span class="line">                datastore_version=datastore_version.name)</span><br><span class="line"></span><br><span class="line">        nodes = body[<span class="string">&#x27;cluster&#x27;</span>][<span class="string">&#x27;instances&#x27;</span>]</span><br><span class="line">        instances = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            flavor_id = utils.get_id_from_href(node[<span class="string">&#x27;flavorRef&#x27;</span>])</span><br><span class="line">            volume_size = volume_type = nics = availability_zone = <span class="literal">None</span></span><br><span class="line">            modules = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;volume&#x27;</span> <span class="keyword">in</span> node:</span><br><span class="line">                volume_size = int(node[<span class="string">&#x27;volume&#x27;</span>][<span class="string">&#x27;size&#x27;</span>])</span><br><span class="line">                volume_type = node[<span class="string">&#x27;volume&#x27;</span>].get(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;nics&#x27;</span> <span class="keyword">in</span> node:</span><br><span class="line">                nics = node[<span class="string">&#x27;nics&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;availability_zone&#x27;</span> <span class="keyword">in</span> node:</span><br><span class="line">                availability_zone = node[<span class="string">&#x27;availability_zone&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;modules&#x27;</span> <span class="keyword">in</span> node:</span><br><span class="line">                modules = node[<span class="string">&#x27;modules&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            instances.append(&#123;<span class="string">&quot;flavor_id&quot;</span>: flavor_id,</span><br><span class="line">                              <span class="string">&quot;volume_size&quot;</span>: volume_size,</span><br><span class="line">                              <span class="string">&quot;volume_type&quot;</span>: volume_type,</span><br><span class="line">                              <span class="string">&quot;nics&quot;</span>: nics,</span><br><span class="line">                              <span class="string">&quot;availability_zone&quot;</span>: availability_zone,</span><br><span class="line">                              <span class="string">&#x27;region_name&#x27;</span>: node.get(<span class="string">&#x27;region_name&#x27;</span>),</span><br><span class="line">                              <span class="string">&quot;modules&quot;</span>: modules&#125;)</span><br><span class="line"></span><br><span class="line">        locality = body[<span class="string">&#x27;cluster&#x27;</span>].get(<span class="string">&#x27;locality&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> locality:</span><br><span class="line">            locality_domain = [<span class="string">&#x27;affinity&#x27;</span>, <span class="string">&#x27;anti-affinity&#x27;</span>]</span><br><span class="line">            locality_domain_msg = (<span class="string">&quot;Invalid locality &#x27;%s&#x27;. &quot;</span></span><br><span class="line">                                   <span class="string">&quot;Must be one of [&#x27;%s&#x27;]&quot;</span> %</span><br><span class="line">                                   (locality,</span><br><span class="line">                                    <span class="string">&quot;&#x27;, &#x27;&quot;</span>.join(locality_domain)))</span><br><span class="line">            <span class="keyword">if</span> locality <span class="keyword">not</span> <span class="keyword">in</span> locality_domain:</span><br><span class="line">                <span class="keyword">raise</span> exception.BadRequest(message=locality_domain_msg)</span><br><span class="line"></span><br><span class="line">        configuration = body[<span class="string">&#x27;cluster&#x27;</span>].get(<span class="string">&#x27;configuration&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        context.notification = notification.DBaaSClusterCreate(context,</span><br><span class="line">                                                               request=req)</span><br><span class="line">        <span class="keyword">with</span> StartNotification(context, name=name, datastore=datastore.name,</span><br><span class="line">                               datastore_version=datastore_version.name):</span><br><span class="line">            cluster = models.Cluster.create(context, name, datastore,</span><br><span class="line">                                            datastore_version, instances,</span><br><span class="line">                                            extended_properties,</span><br><span class="line">                                            locality, configuration)</span><br><span class="line">        cluster.locality = locality</span><br><span class="line">        view = views.load_view(cluster, req=req, load_servers=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> wsgi.Result(view.data(), <span class="number">200</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>分析ClusterController中create的流程，create做了以下三件事：</p>
<ol>
<li>根据配置文件中，指定数据库类型的cluster_support配置，检查该数据库是否支持集群模式。</li>
<li>拼装集群内instance配置参数。</li>
<li>调用trove.cluster.models.Cluster.create()，创建数据库集群。</li>
</ol>
<p>创建实际是在<code>trove.cluster.models:Cluster.create</code>执行的，进一步分析<strong>trove.cluster.models</strong>中的创建流程，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.cluster.models</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">cls, context, name, datastore, datastore_version,</span></span></span><br><span class="line"><span class="function"><span class="params">               instances, extended_properties, locality, configuration</span>):</span></span><br><span class="line">        locality = srv_grp.ServerGroup.build_scheduler_hint(</span><br><span class="line">            context, locality, name)</span><br><span class="line">        api_strategy = strategy.load_api_strategy(datastore_version.manager)</span><br><span class="line">        <span class="keyword">return</span> api_strategy.cluster_class.create(context, name, datastore,</span><br><span class="line">                                                 datastore_version, instances,</span><br><span class="line">                                                 extended_properties,</span><br><span class="line">                                                 locality, configuration)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>trove.cluster.models:Cluster.create</code>做了三件事，依次分别是：</p>
<ol>
<li>调用novaclient，为cluster创建server group，便于统一管理。</li>
<li>根据数据库版本，加载指定的api strategy。</li>
<li>调用api strategy中对应的create方法。</li>
</ol>
<p>研究strategy究竟做了哪些事情，这里看下<code>load_api_strategy</code>代码，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.common.strategise.cluster.strategy</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_api_strategy</span>(<span class="params">manager</span>):</span></span><br><span class="line">    clazz = CONF.get(manager).get(<span class="string">&#x27;api_strategy&#x27;</span>)</span><br><span class="line">    LOG.debug(<span class="string">&quot;Loading class %s&quot;</span>, clazz)</span><br><span class="line">    api_strategy = import_class(clazz)</span><br><span class="line">    <span class="keyword">return</span> api_strategy()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>strategy根据配置文件中，不同数据库配置的<code>api_strategy</code>参数，找到指定的管理代码，从而实现不同的数据库类型统一的管理。这里以<code>galera_common</code>为例，进行后续分析，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.common.strategies.cluster.experimental.galera_common.api</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">cls, context, name, datastore, datastore_version,</span></span></span><br><span class="line"><span class="function"><span class="params">               instances, extended_properties, locality, configuration</span>):</span></span><br><span class="line">        LOG.debug(<span class="string">&quot;Initiating Galera cluster creation.&quot;</span>)</span><br><span class="line">        ds_conf = CONF.get(datastore_version.manager)</span><br><span class="line">        <span class="comment"># Check number of instances is at least min_cluster_member_count</span></span><br><span class="line">        <span class="keyword">if</span> len(instances) &lt; ds_conf.min_cluster_member_count:</span><br><span class="line">            <span class="keyword">raise</span> exception.ClusterNumInstancesNotLargeEnough(</span><br><span class="line">                num_instances=ds_conf.min_cluster_member_count)</span><br><span class="line">        cls._validate_cluster_instances(context, instances, datastore,</span><br><span class="line">                                        datastore_version)</span><br><span class="line">        <span class="comment"># Updating Cluster Task</span></span><br><span class="line">        db_info = cluster_models.DBCluster.create(</span><br><span class="line">            name=name, tenant_id=context.project_id,</span><br><span class="line">            datastore_version_id=datastore_version.id,</span><br><span class="line">            task_status=ClusterTasks.BUILDING_INITIAL,</span><br><span class="line">            configuration_id=configuration)</span><br><span class="line"></span><br><span class="line">        cls._create_instances(context, db_info, datastore, datastore_version,</span><br><span class="line">                              instances, extended_properties, locality,</span><br><span class="line">                              configuration)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calling taskmanager to further proceed for cluster-configuration</span></span><br><span class="line">        task_api.load(context, datastore_version.manager).create_cluster(</span><br><span class="line">            db_info.id)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls(context, db_info, datastore, datastore_version)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_instances</span>(<span class="params">context, db_info, datastore, datastore_version,</span></span></span><br><span class="line"><span class="function"><span class="params">                          instances, extended_properties, locality,</span></span></span><br><span class="line"><span class="function"><span class="params">                          configuration_id</span>):</span></span><br><span class="line">        member_config = &#123;<span class="string">&quot;id&quot;</span>: db_info.id,</span><br><span class="line">                         <span class="string">&quot;instance_type&quot;</span>: <span class="string">&quot;member&quot;</span>&#125;</span><br><span class="line">        name_index = int(time.time())</span><br><span class="line">        <span class="keyword">for</span> instance <span class="keyword">in</span> instances:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> instance.get(<span class="string">&quot;name&quot;</span>):</span><br><span class="line">                instance[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;%s-member-%s&quot;</span> % (db_info.name,</span><br><span class="line">                                                     str(name_index))</span><br><span class="line">                name_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [Instance.create(context,</span><br><span class="line">                                instance[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">                                instance[<span class="string">&#x27;flavor_id&#x27;</span>],</span><br><span class="line">                                datastore_version.image_id,</span><br><span class="line">                                [], [],</span><br><span class="line">                                datastore, datastore_version,</span><br><span class="line">                                instance.get(<span class="string">&#x27;volume_size&#x27;</span>, <span class="literal">None</span>),</span><br><span class="line">                                <span class="literal">None</span>,</span><br><span class="line">                                availability_zone=instance.get(</span><br><span class="line">                                    <span class="string">&#x27;availability_zone&#x27;</span>, <span class="literal">None</span>),</span><br><span class="line">                                nics=instance.get(<span class="string">&#x27;nics&#x27;</span>, <span class="literal">None</span>),</span><br><span class="line">                                configuration_id=configuration_id,</span><br><span class="line">                                cluster_config=member_config,</span><br><span class="line">                                volume_type=instance.get(</span><br><span class="line">                                    <span class="string">&#x27;volume_type&#x27;</span>, <span class="literal">None</span>),</span><br><span class="line">                                modules=instance.get(<span class="string">&#x27;modules&#x27;</span>),</span><br><span class="line">                                locality=locality,</span><br><span class="line">                                region_name=instance.get(<span class="string">&#x27;region_name&#x27;</span>)</span><br><span class="line">                                )</span><br><span class="line">                <span class="keyword">for</span> instance <span class="keyword">in</span> instances]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_validate_cluster_instances</span>(<span class="params">context, instances, datastore,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    datastore_version</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate the flavor and volume&quot;&quot;&quot;</span></span><br><span class="line">        ds_conf = CONF.get(datastore_version.manager)</span><br><span class="line">        num_instances = len(instances)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Checking volumes and get delta for quota check</span></span><br><span class="line">        cluster_models.validate_instance_flavors(</span><br><span class="line">            context, instances, ds_conf.volume_support, ds_conf.device_path)</span><br><span class="line"></span><br><span class="line">        req_volume_size = cluster_models.get_required_volume_size(</span><br><span class="line">            instances, ds_conf.volume_support)</span><br><span class="line"></span><br><span class="line">        cluster_models.assert_homogeneous_cluster(instances)</span><br><span class="line"></span><br><span class="line">        deltas = &#123;<span class="string">&#x27;instances&#x27;</span>: num_instances, <span class="string">&#x27;volumes&#x27;</span>: req_volume_size&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># quota check</span></span><br><span class="line">        check_quotas(context.project_id, deltas)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Checking networks are same for the cluster</span></span><br><span class="line">        cluster_models.validate_instance_nics(context, instances)    </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>galera_common.api中，做了如下几个步骤：</p>
<ol>
<li>检查集群内的实例数量是否满足配置中要求的集群最小实例数。</li>
<li>检查集群实例配置。</li>
<li>更新cluster状态信息。</li>
<li>创建集群内各实例。</li>
<li>调用<code>galera_common.taskmanager.create_cluster</code>进行进一步的集群配置。</li>
</ol>
<p>galera_common.taskmanager.create_cluster源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.common.strategies.cluster.experimental.galera_common.taskmanager</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_cluster</span>(<span class="params">self, context, cluster_id</span>):</span></span><br><span class="line">        LOG.debug(<span class="string">&quot;Begin create_cluster for id: %s.&quot;</span>, cluster_id)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_create_cluster</span>():</span></span><br><span class="line">            <span class="comment"># Fetch instances by cluster_id against instances table.</span></span><br><span class="line">            db_instances = DBInstance.find_all(cluster_id=cluster_id).all()</span><br><span class="line">            instance_ids = [db_instance.id <span class="keyword">for</span> db_instance <span class="keyword">in</span> db_instances]</span><br><span class="line"></span><br><span class="line">            LOG.debug(<span class="string">&quot;Waiting for instances to get to cluster-ready status.&quot;</span>)</span><br><span class="line">            <span class="comment"># Wait for cluster members to get to cluster-ready status.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._all_instances_ready(instance_ids, cluster_id):</span><br><span class="line">                <span class="keyword">raise</span> TroveError(_(<span class="string">&quot;Instances in cluster did not report &quot;</span></span><br><span class="line">                                   <span class="string">&quot;ACTIVE&quot;</span>))</span><br><span class="line"></span><br><span class="line">            LOG.debug(<span class="string">&quot;All members ready, proceeding for cluster setup.&quot;</span>)</span><br><span class="line">            instances = [Instance.load(context, instance_id) <span class="keyword">for</span> instance_id</span><br><span class="line">                         <span class="keyword">in</span> instance_ids]</span><br><span class="line"></span><br><span class="line">            cluster_ips = [self.get_ip(instance) <span class="keyword">for</span> instance <span class="keyword">in</span> instances]</span><br><span class="line">            instance_guests = []</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Create replication user and password for synchronizing the</span></span><br><span class="line">            <span class="comment"># galera cluster</span></span><br><span class="line">            replication_user = &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: self.CLUSTER_REPLICATION_USER,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>: utils.generate_random_password(),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Galera cluster name must be unique and be shorter than a full</span></span><br><span class="line">            <span class="comment"># uuid string so we remove the hyphens and chop it off. It was</span></span><br><span class="line">            <span class="comment"># recommended to be 16 chars or less.</span></span><br><span class="line">            <span class="comment"># (this is not currently documented on Galera docs)</span></span><br><span class="line">            cluster_name = utils.generate_uuid().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>)[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">            LOG.debug(<span class="string">&quot;Configuring cluster configuration.&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># Set the admin password for all the instances because the</span></span><br><span class="line">                <span class="comment"># password in the my.cnf will be wrong after the joiner</span></span><br><span class="line">                <span class="comment"># instances syncs with the donor instance.</span></span><br><span class="line">                admin_password = str(utils.generate_random_password())</span><br><span class="line"></span><br><span class="line">                bootstrap = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> instance <span class="keyword">in</span> instances:</span><br><span class="line">                    guest = self.get_guest(instance)</span><br><span class="line">                    instance_guests.append(guest)</span><br><span class="line">                    guest.reset_admin_password(admin_password)</span><br><span class="line">                    <span class="comment"># render the conf.d/cluster.cnf configuration</span></span><br><span class="line">                    cluster_configuration = self._render_cluster_config(</span><br><span class="line">                        context,</span><br><span class="line">                        instance,</span><br><span class="line">                        <span class="string">&quot;,&quot;</span>.join(cluster_ips),</span><br><span class="line">                        cluster_name,</span><br><span class="line">                        replication_user)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># push the cluster config and bootstrap the first instance</span></span><br><span class="line">                    guest.install_cluster(replication_user,</span><br><span class="line">                                          cluster_configuration,</span><br><span class="line">                                          bootstrap)</span><br><span class="line">                    bootstrap = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                LOG.debug(<span class="string">&quot;Finalizing cluster configuration.&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> guest <span class="keyword">in</span> instance_guests:</span><br><span class="line">                    guest.cluster_complete()</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                LOG.exception(<span class="string">&quot;Error creating cluster.&quot;</span>)</span><br><span class="line">                self.update_statuses_on_failure(cluster_id)</span><br><span class="line"></span><br><span class="line">        timeout = Timeout(CONF.cluster_usage_timeout)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _create_cluster()</span><br><span class="line">            self.reset_task()</span><br><span class="line">        <span class="keyword">except</span> Timeout <span class="keyword">as</span> t:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">is</span> <span class="keyword">not</span> timeout:</span><br><span class="line">                <span class="keyword">raise</span>  <span class="comment"># not my timeout</span></span><br><span class="line">            LOG.exception(<span class="string">&quot;Timeout for building cluster.&quot;</span>)</span><br><span class="line">            self.update_statuses_on_failure(cluster_id)</span><br><span class="line">        <span class="keyword">except</span> TroveError:</span><br><span class="line">            LOG.exception(<span class="string">&quot;Error creating cluster %s.&quot;</span>, cluster_id)</span><br><span class="line">            self.update_statuses_on_failure(cluster_id)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            timeout.cancel()</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&quot;End create_cluster for id: %s.&quot;</span>, cluster_id)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>taskmanager依次做了以下几件事情：</p>
<ol>
<li>根据cluster id，定位到集群内所有的instance。</li>
<li>检测所有instance状态是否为ACTIVE。</li>
<li>生成集群配置信息。</li>
<li>依次调用各个instance内的guest agent，更新集群配置信息，并启动第一个节点。</li>
<li>更新集群状态。</li>
</ol>
<p>到这里，所有流程就走完了。为了更深一步了解trove，这里我们继续深入实例，研究instance内guest agent操作，具体干了哪些事情，首先从guest agent启动代码入手，看guest agent如何响应rpc调用，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.cmd.guest</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg <span class="keyword">as</span> openstack_cfg</span><br><span class="line"><span class="keyword">from</span> oslo_log <span class="keyword">import</span> log <span class="keyword">as</span> logging</span><br><span class="line"><span class="keyword">from</span> oslo_service <span class="keyword">import</span> service <span class="keyword">as</span> openstack_service</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> trove.common <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">from</span> trove.common <span class="keyword">import</span> debug_utils</span><br><span class="line"><span class="keyword">from</span> trove.common.i18n <span class="keyword">import</span> _</span><br><span class="line"><span class="keyword">from</span> trove.guestagent <span class="keyword">import</span> api <span class="keyword">as</span> guest_api</span><br><span class="line"></span><br><span class="line">CONF = cfg.CONF</span><br><span class="line"><span class="comment"># The guest_id opt definition must match the one in common/cfg.py</span></span><br><span class="line">CONF.register_opts([openstack_cfg.StrOpt(<span class="string">&#x27;guest_id&#x27;</span>, default=<span class="literal">None</span>,</span><br><span class="line">                                         help=<span class="string">&quot;ID of the Guest Instance.&quot;</span>),</span><br><span class="line">                    openstack_cfg.StrOpt(<span class="string">&#x27;instance_rpc_encr_key&#x27;</span>,</span><br><span class="line">                                         help=(<span class="string">&#x27;Key (OpenSSL aes_cbc) for &#x27;</span></span><br><span class="line">                                               <span class="string">&#x27;instance RPC encryption.&#x27;</span>))])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cfg.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, <span class="literal">None</span>)</span><br><span class="line">    debug_utils.setup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> trove.guestagent <span class="keyword">import</span> dbaas</span><br><span class="line">    manager = dbaas.datastore_registry().get(CONF.datastore_manager)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> manager:</span><br><span class="line">        msg = (_(<span class="string">&quot;Manager class not registered for datastore manager %s&quot;</span>) %</span><br><span class="line">               CONF.datastore_manager)</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> CONF.guest_id:</span><br><span class="line">        msg = (_(<span class="string">&quot;The guest_id parameter is not set. guest_info.conf &quot;</span></span><br><span class="line">               <span class="string">&quot;was not injected into the guest or not read by guestagent&quot;</span>))</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(msg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># BUG(1650518): Cleanup in the Pike release</span></span><br><span class="line">    <span class="comment"># make it fatal if CONF.instance_rpc_encr_key is None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># rpc module must be loaded after decision about thread monkeypatching</span></span><br><span class="line">    <span class="comment"># because if thread module is not monkeypatched we can&#x27;t use eventlet</span></span><br><span class="line">    <span class="comment"># executor from oslo_messaging library.</span></span><br><span class="line">    <span class="keyword">from</span> trove <span class="keyword">import</span> rpc</span><br><span class="line">    rpc.init(CONF)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> trove.common.rpc <span class="keyword">import</span> service <span class="keyword">as</span> rpc_service</span><br><span class="line">    server = rpc_service.RpcService(</span><br><span class="line">        key=CONF.instance_rpc_encr_key,</span><br><span class="line">        topic=<span class="string">&quot;guestagent.%s&quot;</span> % CONF.guest_id,</span><br><span class="line">        manager=manager, host=CONF.guest_id,</span><br><span class="line">        rpc_api_version=guest_api.API.API_LATEST_VERSION)</span><br><span class="line"></span><br><span class="line">    launcher = openstack_service.launch(CONF, server, restart_method=<span class="string">&#x27;mutate&#x27;</span>)</span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure>

<p>guest agent启动流程中，做了如下几件事：</p>
<ol>
<li><p>从<code>trove.guestagent.dbaas</code>中到manager入口函数，找到符合的datastore_manager。</p>
</li>
<li><p>将datastore_manager注册进rpcservice内，远程调用时接收到指定的rpc操作后，即可触发manager对应的方法。</p>
</li>
</ol>
<p>这里我们看下<code>trove.guestagent.dbaas</code>注册了哪些入口，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.guestagent.dbaas</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Handles all processes within the Guest VM, considering it as a Platform</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The :py:class:`GuestManager` class is a :py:class:`nova.manager.Manager` that</span></span><br><span class="line"><span class="string">handles RPC calls relating to Platform specific operations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Related Flags**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> oslo_log <span class="keyword">import</span> log <span class="keyword">as</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> trove.common <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">from</span> trove.common.i18n <span class="keyword">import</span> _</span><br><span class="line"><span class="keyword">from</span> trove.common <span class="keyword">import</span> utils</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOG = logging.getLogger(__name__)</span><br><span class="line">defaults = &#123;</span><br><span class="line">    <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.mysql.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;percona&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.percona.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pxc&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.pxc.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;redis&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.redis.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cassandra&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.cassandra.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;couchbase&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.couchbase.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mongodb&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.mongodb.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;postgresql&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.postgresql.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;couchdb&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.couchdb.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;vertica&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.vertica.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;db2&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.db2.manager.Manager&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mariadb&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;trove.guestagent.datastore.experimental.mariadb.manager.Manager&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datastore_registry</span>():</span></span><br><span class="line">    <span class="keyword">return</span> dict(chain(defaults.items(),</span><br><span class="line">                get_custom_managers().items()))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>dbaas内我们可以到所有数据库的入口函数，即可根据rpc的消息类型，找到对应的入口，对应的影响函数了。回到taskmanager发消息的流程，taskmanager调用guest内的install_cluster方法，我们看下install_cluster的方法，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.common.strategies.cluster.experimental.galera_common.guestagent</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GaleraCommonGuestAgentAPI</span>(<span class="params">guest_api.API</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Cluster Specific Datastore Guest API</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    **** VERSION CONTROLLED API ****</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The methods in this class are subject to version control as</span></span><br><span class="line"><span class="string">    coordinated by guestagent/api.py.  Whenever a change is made to</span></span><br><span class="line"><span class="string">    any API method in this class, add a version number and comment</span></span><br><span class="line"><span class="string">    to the top of guestagent/api.py and use the version number as</span></span><br><span class="line"><span class="string">    appropriate in this file</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_cluster</span>(<span class="params">self, replication_user, cluster_configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        bootstrap</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Install the cluster.&quot;&quot;&quot;</span></span><br><span class="line">        LOG.debug(<span class="string">&quot;Installing Galera cluster.&quot;</span>)</span><br><span class="line">        version = guest_api.API.API_BASE_VERSION</span><br><span class="line"></span><br><span class="line">        self._call(<span class="string">&quot;install_cluster&quot;</span>, CONF.cluster_usage_timeout,</span><br><span class="line">                   version=version,</span><br><span class="line">                   replication_user=replication_user,</span><br><span class="line">                   cluster_configuration=cluster_configuration,</span><br><span class="line">                   bootstrap=bootstrap)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>向guest发送了一个同步调用的rpc请求（<code>_call</code>为同步调用，<code>_cast</code>为异步调用），触发<code>install_cluster</code>方法，这里我们从manager入手，看下install_cluster具体干了哪些事情，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.guestagent.datastore.galera_common.manager</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_cluster</span>(<span class="params">self, context, replication_user, cluster_configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        bootstrap</span>):</span></span><br><span class="line">        app = self.mysql_app(self.mysql_app_status.get())</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            app.install_cluster(</span><br><span class="line">                replication_user, cluster_configuration, bootstrap)</span><br><span class="line">            LOG.debug(<span class="string">&quot;install_cluster call has finished.&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            LOG.exception(<span class="string">&#x27;Cluster installation failed.&#x27;</span>)</span><br><span class="line">            app.status.set_status(</span><br><span class="line">                rd_instance.ServiceStatuses.FAILED)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里，实际上就调用了service内对应的install_cluster方法，做了些异常判断，进入service内，看下具体干了那些事，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trove.guestagent.datastore.galera_common.service</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GaleraApp</span>(<span class="params">service.BaseMySqlApp</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, status, local_sql_client, keep_alive_connection_cls</span>):</span></span><br><span class="line">        super(GaleraApp, self).__init__(status, local_sql_client,</span><br><span class="line">                                        keep_alive_connection_cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_cluster</span>(<span class="params">self, replication_user, cluster_configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        bootstrap=False</span>):</span></span><br><span class="line">        LOG.info(<span class="string">&quot;Installing cluster configuration.&quot;</span>)</span><br><span class="line">        self._grant_cluster_replication_privilege(replication_user)</span><br><span class="line">        self.stop_db()</span><br><span class="line">        self.write_cluster_configuration_overrides(cluster_configuration)</span><br><span class="line">        self.wipe_ib_logfiles()</span><br><span class="line">        LOG.debug(<span class="string">&quot;bootstrap the instance? : %s&quot;</span>, bootstrap)</span><br><span class="line">        <span class="comment"># Have to wait to sync up the joiner instances with the donor instance.</span></span><br><span class="line">        <span class="keyword">if</span> bootstrap:</span><br><span class="line">            self._bootstrap_cluster(timeout=CONF.restore_usage_timeout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.start_mysql(timeout=CONF.restore_usage_timeout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_grant_cluster_replication_privilege</span>(<span class="params">self, replication_user</span>):</span></span><br><span class="line">        LOG.info(<span class="string">&quot;Granting Replication Slave privilege.&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> self.local_sql_client(self.get_engine()) <span class="keyword">as</span> client:</span><br><span class="line">            perms = [<span class="string">&#x27;REPLICATION CLIENT&#x27;</span>, <span class="string">&#x27;RELOAD&#x27;</span>, <span class="string">&#x27;LOCK TABLES&#x27;</span>]</span><br><span class="line">            g = sql_query.Grant(permissions=perms,</span><br><span class="line">                                user=replication_user[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">                                clear=replication_user[<span class="string">&#x27;password&#x27;</span>])</span><br><span class="line">            t = text(str(g))</span><br><span class="line">            client.execute(t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_cluster_configuration_overrides</span>(<span class="params">self, cluster_configuration</span>):</span></span><br><span class="line">        self.configuration_manager.apply_system_override(</span><br><span class="line">            cluster_configuration, <span class="string">&#x27;cluster&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap_cluster</span>(<span class="params">self, timeout=<span class="number">120</span></span>):</span></span><br><span class="line">        LOG.info(<span class="string">&quot;Bootstraping cluster.&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            utils.execute_with_timeout(</span><br><span class="line">                self.mysql_service[<span class="string">&#x27;cmd_bootstrap_galera_cluster&#x27;</span>],</span><br><span class="line">                shell=<span class="literal">True</span>, timeout=timeout)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            LOG.exception(<span class="string">&quot;Error bootstrapping cluster.&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(_(<span class="string">&quot;Service is not discovered.&quot;</span>))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里就是各实例内的具体操作流程了，流程如下：</p>
<ol>
<li>对集群内各实例赋权。</li>
<li>停止数据库服务。</li>
<li>更新MySQL配置文件。</li>
<li>删除ib_logfiles。</li>
<li>首节点为启动集群方式启动，其余节点直接启动mysql即可。</li>
</ol>
<p>到这里，MySQL集群创建流程即全部解析完成。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/api-ref/database/">OpenStack Documentation: Database API</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/trove/wallaby/install/index.html">OpenStack Documentation: Database Service</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/releasenotes/trove/train.html#relnotes-12-0-0-stable-train">OpenStack Documentation: Trove Release Notes</a></li>
<li><a target="_blank" rel="noopener" href="https://opendev.org/openstack/trove">OpenDev: OpenStack Trove</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">任翌博</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://renyb2.github.io/2022/01/25/OpenStack%E7%A0%94%E5%8F%91%EF%BC%9ATrove-Cluster-Controller/">https://renyb2.github.io/2022/01/25/OpenStack%E7%A0%94%E5%8F%91%EF%BC%9ATrove-Cluster-Controller/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://renyb2.github.io" target="_blank">任翌博的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OpenStack/">OpenStack</a><a class="post-meta__tags" href="/tags/Trove/">Trove</a></div><div class="post_share"><div class="social-share" data-image="https://www.leixue.com/uploads/2019/07/OpenStack.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/03/Linux%E8%BF%90%E7%BB%B4%EF%BC%9ACPU-load-average%E8%BF%87%E9%AB%98/"><img class="prev-cover" src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2734045988,4035371764&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux运维：CPU load average过高</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/24/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%9ASysbench/"><img class="next-cover" src="https://pic3.zhimg.com/9a2e9d9501bbb830b7670afada5f3a4d_1200x500.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">性能测试工具：Sysbench</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/08/05/OpenStack部署：Trove/" title="OpenStack部署：Trove"><img class="relatedPosts_cover" src="https://www.leixue.com/uploads/2019/07/OpenStack.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-05</div><div class="relatedPosts_title">OpenStack部署：Trove</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/22/Kubernetes部署：OpenStack服务配置HTTPS/" title="Kubernetes部署：OpenStack服务配置HTTPS"><img class="relatedPosts_cover" src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=175322010,70959622&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="relatedPosts_title">Kubernetes部署：OpenStack服务配置HTTPS</div></div></a></div><div class="relatedPosts_item"><a href="/2020/11/06/OpenStack使用：自定义实例root密码/" title="OpenStack使用：自定义实例root密码"><img class="relatedPosts_cover" src="https://www.leixue.com/uploads/2019/07/OpenStack.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-06</div><div class="relatedPosts_title">OpenStack使用：自定义实例root密码</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/10/OpenStack研发：Cyborg/" title="OpenStack研发：Cyborg"><img class="relatedPosts_cover" src="https://www.leixue.com/uploads/2019/07/OpenStack.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-10</div><div class="relatedPosts_title">OpenStack研发：Cyborg</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/22/OpenStack研发：Glance-Image-Cache/" title="OpenStack研发：Glance Image Cache"><img class="relatedPosts_cover" src="https://www.pinclipart.com/picdir/big/201-2017709_a-quick-study-guide-for-the-coa-exam.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-22</div><div class="relatedPosts_title">OpenStack研发：Glance Image Cache</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/05/OpenStack研发：Glance-Image-Soft-Delete/" title="OpenStack研发：Glance Image Soft Delete"><img class="relatedPosts_cover" src="https://www.pinclipart.com/picdir/big/201-2017709_a-quick-study-guide-for-the-coa-exam.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-05</div><div class="relatedPosts_title">OpenStack研发：Glance Image Soft Delete</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 任翌博</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script></div></body></html>